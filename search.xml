<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从函数指针看C语言的面向对象实现]]></title>
    <url>%2F2020%2F05%2F05%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9C%8BC%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[指针函数、函数指针、回调函数==指针函数==：指针函数本质是一个函数，只不过返回值为某一类型的指针（地址值）。函数返回值必须用同类型的变量来接受，也就是说，指针函数的返回值必须赋值给同类型的指针变量。 ==函数指针==：函数指针本质是一个指针，只不过这个指针指向一个函数。指针变量通畅指向一个整形、字符型、或者数组等变量，而函数指针指向的是函数。常见的函数都有其入口，比如main()函数是整个程序的入口，我们调用的其他函数都有其特定的入口，正如我们可以通过地址找到相应的变量一样，我们也可以通过地址找到相应的函数。而这个存储着函数地址的指针就是函数指针。可以通过指针访问相应的变量，函数指针也可以像函数一样用于调用函数、传递参数。 ==回调函数==：函数指针作为某个函数的参数。理解回调函数，我们先要搞清楚回调函数有什么作用。比如老板、经理、你三个角色。老板通常是规则的指定着，经理按照规则指派相应的人去做事，而你就是任务的具体执行者。当老板要求经理去做一个事情，那么老板就是主调函数，经理就是回调函数，你按照规则去处理事情就是相应回调函数。你处理的结果会反馈给经理，经理拿着你的结果再反馈给老板。老板就可以使用这个结果去做相关的事情了。在这个环节中，你只需要按照指定的规则去做事，而经理不需要考虑事情是怎么做的，他只需要把相应的事情分配给对应的人去处理即可，然后将获取的结果反馈给老板。如果规则有变，只需要对应的员工知道哪里改变了，而经理不需要关注这些细节。函数指针的应用场景 普通的函数指针，指向函数，实现比如勾子函数等 回调函数，实现在特定情况下需要不同的处理，或者对不同些数据的不同处理 封装，函数模板，构造对象（类似于C++虚函数）等等 结构体，是定义了一个用户自定义内型，那么这个内型就可以定义N多的变量，不同的变量拥有不同的值，也包括函数指针的值，这样就实现了”多态”，模拟OOP中的虚函数。 函数指针声明， 函数原型int sum(int,int);是一个返回值为int类型, 参数是两个int类型的函数. 如何声明该类型函数的指针呢？将函数名替换成(pf)形式即可，即我们把sum替换成(fp)即可，fp为函数指针名int （*fp）(int,int); 这样就声明了和sum函数类型相同的函数指针fp, ==和fp为一体==，说明了fp为指针类型; ==fp需要用括号括起来==，否则就会变成int *fp(int,int);,这时候意义就变化了，成立一个返回值为一个int指针类型的函数，函数一个函数指针。为了避免每次声明函数指针的时候方便，函数指针可以用typedef定义： 12typedef int (*myFun)(int,int);//为该函数指针起一个新名字myFun f1; //声明myFun类型的函数指针f1 函数指针赋值1234567891011121314#include&lt;stdio.h&gt;int mytest(int a,int b)&#123; return a+b;&#125;typedef int(*fp)(int,int);int main(void)&#123; fp func1 = mytest; //表达式1 fp func2 = &amp;mytest;//表达式2 printf(&quot;%d\n&quot;,func1); printf(&quot;%d\n&quot;,func2); return 0;&#125; 这里，声明返回类型为int，接受两个int类型参数的函数指针func1和func2，分别给它们进行了赋值。表达式1和表达式2在作用上是一样的。由于函数名在被使用时总是由编译器把它转换为函数指针，因此前面加上&amp;只是显式的说明了这一点而已。 函数指针的调用 12345678910111213#include&lt;stdio.h&gt;int mytest(int a,int b)&#123; return a+b;&#125;typedef int(*fp)(int,int);int main(void)&#123; fp func = mytest; //表达式1 func(1,2); //表达式1 (*func)(3,4); //表达式2 return 0;&#125; 在函数指针后面加括号，并传入参数即可调用，其中表达式1和表达式2似乎都可以成功调用，但是哪个是正确的呢？ANSI C认为这两种形式等价。 函数指针的用途：1、作为句柄函数传入，以库函数qsort排序函数为例， 1void qsort(void *base,size_t nmemb,size_t size , int(*compar)(const void *,const void *)); 拆开来看如下：1void qsort(void *base, size_t nmemb, size_t size, ); 拿掉第四个参数后，它是一个无返回值的函数，接受4个参数，第一个是void*类型，代表原始数组，第二个是size_t类型，代表数据数量，第三个是size_t类型，代表单个数据占用空间大小，而第四个参数是函数指针。这第四个参数，即函数指针指向的是什么类型呢？1int(*compar)(const void *,const void *) 这是一个接受两个const void*类型入参，返回值为int的函数指针。这个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，就可以帮我们对任意数据类型的数组进行排序。 结构体中包含函数指针,可以像一般变量一样,包含函数指针变量.下面是一种简单的实现1234567891011121314struct opt &#123; int x,y; int (*func)(int,int); //函数指针 &#125;; void main() &#123; struct opt demo; opt.func=add2; //结构体函数指针赋值 //demo.func=&amp;add2; //结构体函数指针赋值 printf(&quot;func(3,4)=%d\n&quot;,opt.func(3,4)); demo.func=add1; printf(&quot;func(3,4)=%d\n&quot;,opt.func(3,4)); &#125; C语言中的struct是最接近类的概念，但是在C语言的struct中只有成员，不能有函数，但是可以有指向函数的指针，们使用函数。12345678910111213141516171819202122232425262728typedef struct student &#123; int id; char name[50]; void (*init)(); void (*process)(int id, char *name); void (*destroy)(); &#125;stu; void init() &#123; /*do something*/ &#125; void process(int id, char *name) &#123; /*do something*/ &#125;void destroy() &#123; /*do something*/ &#125; int main() &#123; stu *stu1 = (stu *)malloc(sizeof(stu)); stu1-&gt;id=1000; strcpy(stu1-&gt;name,&quot;C++&quot;); stu1-&gt;init=init; stu1-&gt;process=process; stu1-&gt;destroy=destroy; printf(&quot;%d\t%s\n&quot;,stu1-&gt;id,stu1-&gt;name); stu1-&gt;init(); stu1-&gt;process(stu1-&gt;id, stu1-&gt;name); stu1-&gt;destroy(); free(stu1); return 0; &#125; 函数指针是解耦对象关系的最佳利器 命令模式 – 设计模式命令模式通过增加中转数据结构，使命令下达和命令执行二者依赖于接口，从而达到二者时间上不相关、二者变化方向独立的目的。【好处：代码清晰明了，容易添加和删除，易维护】 12345678910111213141516171819202122232425typedef struct &#123; uint8_t cmd; void (* handle)(char *buffer);&#125; package; static const package packageItems[] =&#123; &#123;0x01, parse_temperature&#125;, &#123;0x02, parse_humidity&#125;, &#123;0x03, parse_illumination&#125;, &#123;0xFF, NULL&#125;,&#125;;static uint8_t parse(void *buffer, uint16_t length)&#123; package *frame = (package *)buffer; if (frame == NULL) &#123; // 异常处理 &#125; const package *entry; for (entry = packageItems; entry-&gt;handle != NULL; ++entry) &#123; if(frame-&gt;cmd == entry-&gt;cmd) &#123; entry-&gt;handle(frame-&gt;data); break; &#125; &#125;&#125; 什么时候会用到这个命令模式呢？ 按键处理 协议解析（串口，网口，CAN，等等）策略模式 – 设计模式12345678910111213141516//开关配置过程typedef void (*ProcStrategy)();ProcStrategy procStrategy;if (strategy == A)&#123; procStrategy = ProcStrategyA;&#125;else&#123; procStrategy = ProcStaregyB;&#125;//核心逻辑处理过程...procStrategy();... 观察者模式 – 设计模式函数需要抽象出来一个action函数123456789101112131415void Eat() &#123; // do something&#125;void Drink() &#123; // do something&#125;void Rest() &#123; // do something&#125;typedef void (*lAction)();lAction flikuiAction[3] = &#123;Eat, Drink, Rest&#125;;//命令响应程序void DoCmd(Cmd *cmd)&#123; for(int i = 0; i &lt; cmd-&gt;cmdNum; i++) &#123; flikuiAction[cmd-&gt;cmd[i]](); &#125;&#125; 状态模式 – 设计模式有这么一个需求，宋江命令李逵杀敌，李逵此时有很多种状态，李逵要根据自己不同的状态做出不同的反应：如果正在吃饭，就扔掉碗进入空闲态，如果处于空闲，就拿起斧子进入战斗状态，如果处于战斗状态，就不做响应。12345678910111213typedef void (*LikuiDoAction)();LikuiDoAction likuiDoAction[3][3] = &#123; /* EATING */ /* FIGHTING */ /* IDLE *//* EAT */ &#123;DoNothing, ThrowAxe, TakeBowl&#125;,/* FIGHT */ &#123;ThrowBowl, DoNothing, TakeAxe&#125;,/* IDLE */ &#123;ThrowBowl, ThrowAxe, DoNothing&#125;&#125;void LikuiAction()&#123; likuiDoAction[SongjiangCmd][LikuiStatus]();&#125; 函数指针与函数调用的性能分析直观上看应该是函数调用开销更小。函数指针调用方案中需要先访问数据区，再访问函数，增加指令开销，同时，数据取值与函数指令加载必须串行执行，影响CPU流水性能；函数调用方案可以做内联优化。]]></content>
      <categories>
        <category>函数指针</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习资源收集]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1、Python1）Python_交互式的学习资源2）Python生成动态图表3）Python文章中精选Top104）忘了Python关键语句？这份备忘录拯救你的记忆5）Python教程：17个冷门但实用的小技巧 2、机器学习相关1）通俗理解PCA降维作用2）18年9月机器学习开源项目Top103）LSTM和GRU的解析4）算法和编程面试题精选TOP505）5种回归损失函数6）精选机器学习文章Top107）如何通过引入硬注意力机制来学习视觉问答任务？8）深度学习必备数学知识之线性代数篇9）构建深度神经网络的实用技巧10）ICML2018见闻 | 迁移学习、多任务学习领域的进展11）8 个超赞的深度学习课程12）合成注意力推理神经网络-Christopher Manning-ICLR201813）李宏毅-201806-中文-Deep Reinforcement Learning精品课程 &emsp;提取码：3eig14）最新深度学习面试题目及答案集锦15）MIT 6.S094 深度学习与自动驾驶课程（下）16）迁移学习在自然语言处理中的应用之通用语言建模17）图说卡尔曼滤波_一份通俗易懂的教程18)）面试了10家公司，以下是一份机器学习面试内容总结19）献给新手的深度学习综述 | 入门20）https://zhuanlan.zhihu.com/p/46396329 3、Git相关1）泪流满面的 11 个 Git 面试题 4、图像处理&amp;计算机视觉1）从R-CNN到RFBNet，目标检测架构5年演进全盘点2）CNN图像分割简史：从R-CNN到Mask3）图像超级补全效果惊艳（附代码）4）用神经网络操纵图像中的自然场景属性 5、文本相关1、基于深度学习的文本分类6大算法2、Scene Text Detection 6、hexo相关1）hexo命令 https://hexo.io/zh-cn/docs/commands.html Others脉冲神经网络(SNN)]]></content>
      <categories>
        <category>学习资源</category>
      </categories>
      <tags>
        <tag>coding，learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络从0到1]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8E0%E5%88%B01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 1980年，心理学家William James出版了第一部论述人脑结构及功能的专著《心理学原理》，首次提出: “一个神经细胞受到刺激激活后可以把刺激传播到另一个神经细胞，并且神经细胞激活是所有细胞输入叠加的结果！” 为人们认识神经网络的活动打开了理论的天窗。基于这个理论假设，从1943年开始，神经网络经历的曲折荡漾的发展，经历了数次的大起大落；理论模型也从单一的神经元感知机开始，发展到包含一个隐藏的多层感知机网络，到现在已卷积神经网络为代表的深度卷积神经网络。&emsp;&emsp;本文以神经网络的发展为线索，从卷积神经网络的结构和应用两个方面进行简单阐述。 1. 什么是卷积神经网络&emsp;&emsp;认识卷积神经网络之前首先要了解两个基本的概念: 1、什么是卷积；2、什么是神经网络。 1.1 什么是卷积 从图像的角度来看卷积: 就是卷积模板在图像上滑动，把对应位置上的元素相城相加得到最终结果的过程。如果考虑翻转则就需要翻转卷积模板。 &emsp;&emsp;卷积核的大小是奇数，如3x3,5x5,7x7等；在cnn的世界里，卷积就是通过不同的卷积核，在不同的图像尺度下，滑动来计算卷积特征的。通过修改卷积核的参数，可以实现对图像进行锐化、模糊等操作，从而检测出图像中的视觉特征；训练cnn的过程，其实也是学习这些卷积和参数的过程。在有限的范围内，使用的卷积核越多，可以学习到的图像特征也就越多。 1.2 什么是神经网络&emsp;&emsp; 按照William James的观点，人工神经网络是基于神经元假设的一种数学描述，是从信息处理的角度将人脑神经元网络进行抽象，从而建立某种模型，可以让神经元按照不同的连接方式组成不同网络的一种数学方法。神经元由大量的节点连接，这个节点称之为激活函数。常见的激活函有: sigmoid、tanh和Relu; $$\begin{eqnarray}Sigmoid(x) = 1/(1+e^{-x}) \\tanh(x)=\frac{1-e^{-2x}} {1+e^{-2x}} \\relu(x)=max(0,x)\end{eqnarray}$$ 三种常用的激活函数&emsp;&emsp;而神经元数学模型就是输入向量X经过加权，通过激活函数f过滤，输出y，也就是： $$\begin{equation}y=f(w_1*x_1+w_2*x_2+b)\end{equation}$$ 这就是感知机的数学表达。$f(x)$但是它只能解决线性问题，对于非线性问题，感知机就无从下手了，比如：异或问题。为了解决非线性问题，又在感知机的基础上提出了前馈神经网络多层感知机 ；如图，给定一组特性向量:$$x=(x_1, x_2, x_3, ….)$$ 通过输入层输入到MLP网络，网络中的隐藏层，相对于增加感知机的决策平面，从而引入多个决策节点，通过级联这些神经元，就可以将原本单个感知机的线性表示表示成多个分段的线性表示，这样就将线性的问题转换成了非线性。也就是无线逼近的积分结果，这样就可以将学习特征用级联的线性表达学习复杂的非线性模式。 1.3 什么是卷积神经网络&emsp;&emsp;卷积区别于传统的前馈神经网络的重要是，多层感知机表达的前馈神经网络的每个神经元都和前一层的输入全部相连接，是一种完全连接的模式；而卷积神经网络通过卷积核与前一层的输入相连接，卷积核的尺寸(感受野)就是卷积神经网络的连接范围，是一种局部的连接的方式。&emsp;&emsp;上图中，假设输入图像是一个1000*1000的图像，左边全连接的网络有100w个隐层的神经元，每个神经元都与输入图像的每个像素相连，那么这个网络就有1000*1000*100w = 10^12个连接；右边局部连接的网络每个节点与输入图像有10*10（实际连接的卷积和尺寸是奇数）的连接，那么100w个隐层的神经元的连接个数是10*10*100w = 10^8，比全连接少了4个数量级。除此之外卷积神经网络还有另外一个特新就是权值共享。也就是在同一层的卷积核对应的参数是相同卷积核。&emsp;&emsp;上图是一个卷积的示例，左边红色为32*32*3的输入数据，蓝色部分是一层卷积网络；右边为卷积网络的神经元数学表述，是和普通的前馈神经网络相同的模型；除了卷积和全连接的区别，卷积神经网络结构也差别很大，是由卷积核的宽度、高度和卷积层数表述的一种长、宽、深度的三维模型，这里的深度就是卷积神经网络的网络层数； 1.3 卷积神经网络的基本结构&emsp;&emsp;经典的卷积神经网络是包含：输入层、卷积层、池化层、激活层、全连接层以及输出层构成的。如下图，为LeNet-5的CNN模型:]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>神经网络，机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python socket编程]]></title>
    <url>%2F2018%2F07%2F22%2Fpython-socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Socket(套接字)，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。服务器端：socket()建立套接字，绑定（bind）并监听（listen），用accept（）等待客户端连接。将accept()写入死循环，每次连接一个客户端，开一个线程。一般情况下建立socket连接后服务器与客户端建立了一个管道，当关闭socket或关闭客户端的时候，会导致管道破裂信号。如果使用默认处理则会导致服务器程序退出。 0. socket函数1socket.socket(family, type, protocol) 参数： family: 套接字python家族支持AF_UNIX、AF_INET、AF_NETLINK和AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM，其中SOCK_STREAM是tcp类型的，SOCK_DGRAM是udp类型的 protocol: 一般不填默认为0. 1. 简单的样例通信样例1.1 TCP服务端TCP是面向连接的，可靠的流协议。流就是不间断的数据结构 123456789101112# for python3.Ximport sockets=socket.socket()host=socket.gethostname() #获取主机地址,xiangdangyuport=1234 #有效端口号是0-65535，低于1024的端口号是系统保留的s.bind((host,port)) #绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址s.listen(5) #开始TCP监听，操作系统可以挂起的最大连接数量；至少为1，一般设置成5即可while True: c,addr=s.accept() #被动接受TCP客户端连接,(阻塞式)等待连接的到来 print ("Go",addr) c.send(('Thank you for connecting').encode()) #发送TCP数据，将string中的数据发送到连接的套接字 c.close() #关闭套接字 &emsp;&emsp;由于Python2.x和Python3.x的区别，socket通信在3.x版本中需要适应encode()和decode()编解码,而python3.x最重要的新特性也是对文本和二进制数据做了更清晰的区分。文本用unicode编码，为str类型，二进制数据则为bytes类型。encode（编码),可以将str类型编码为bytes。decode（译码），可以将bytes类型转换为str类型。&emsp;&emsp;注意：如果不添加encode()和decode()就会报Socket TypeError: a bytes-like object is required, not &#39;str&#39;的错误，因此在发送的时候记得将数据encode()，接收的时候将数据decode() 1.2 TCP客户端12345678import sockets=socket.socket()host=socket.gethostname()port=1234s.connect((host,port))data=s.recv(1024).decode() #接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。print (s.recv(1024).decode()) 1.3 UDP服务端&emsp;&emsp;UDP是一种无连接的，不具有可靠性的数据报文协议这个是插入时间戳的例子，同理这个还可以在tcp的socket实现，各位看官自己实现吧 123456789101112131415161718# for python3.Xfrom socket import *from time import ctimehost = 'localhost'port = 12345buffersize = 1024addr=(host, port)udpSocket = socket(AF_INET, SOCK_DGRAM)udpSocket.bind(addr)while True: print('waiting for message...') data, addr = udpSocket.recvfrom(buffersize) data = data.decode() udpSocket.sendto(('[%s] %s' % (ctime(), data)).encode(), addr) print('...received form and return to:', addr)udpSocket.close() 1.4 UDP客户端123456789101112131415161718from socket import *from time import ctimehost='localhost'port=12345buffersize=1024addr=(host, port)udpClient=socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt;') if not data: break udpClient.sendto(data.encode(), addr) #address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 data,addr=udpClient.recvfrom(buffersize) data = data.decode() if not data: break print(data)udpClient.close() &emsp;&emsp;综上所述，可以得到这样的结论: socket通信，服务器端 要开启一个对应udp或者tcp的scoket，在这个socket里面指定通信的端口的地址；udp服务器的socket这样起，udpScoket=socket(AF_INET, SOCK_DGRAM); 然后在udpSocket里面调用bind()方法绑定通信的地址addr=(host, port)，也就是udpSocket.bind(addr)；然后在开启一个循环通过recvfrom()方法接收udp数据，data, addr = udpSocket.recvfrom(buffersize)，发送出去的话就利用sendto()方法，udpSocket.sendto((&#39;[%s] %s&#39; % (ctime(), data)).encode(), addr)。tcp的socket相对于udp的socket是一种可靠的传输，在起socket的时候不同于udp的主要有两点，一是利用SOCK_STREAM，二是tcp的通信需要在一段时间内监听通信端口是否有数据发来，这是tcp协议所特有的。客户端 服务器端开启了socket服务之后，socket客户端需要对应服务器开启一个对应的socket客户端：tcp开udpClient=socket(AF_INET, SOCK_STREAM)，然后让这个客户端的socket连接到服务器的socket；也就是tcpClient.connect(ADDR)&#39; 这里ADDR=(host, port)udpClient=socket(AF_INET, SOCK_DGRAM)这样客户端就和服务器连接起来了；客户端样用recv()方法接收服务器的数据；用send()方法将数据发送到服务器。udp客户同tcp的方法一样，跟对应模式的socket`方法一直，端口对端口，地址对地址。 2、socketserver模块&emsp;&emsp;socketserver是标准库中的一个高级模块，用于网络客户端与服务器的实现，模块定义了一些类来处理诸如TCP、UDP、UNIX流和UNIX数据报之上的同步网络请求。；python3中，导入socketserver模块, 使用import socketserver. 在使用socketserver的时候必须说先定义一个继承BaseRequestHandler的处理类。 socketserver 模块中包含的类： BaseServer &emsp;包含服务器的核心功能与混合类(min-in)的钩子功能.这个类主用于派生,不要直接生成这个类的类对象,可以考虑使用; TCPServer/UDPServer &emsp;TCPServer基本的网络同步tcp服务器/UDPServer 基本的网络同步udp服务器; ForkingMinIn &emsp;实现了核心的进程化功能,用于与服务器类进行混合(min-in),以提供一些异步特性.不要直接生成这个类的对象; ThreadingMinIn&emsp;实现了核心的线程化功能,用于与服务器类进行混合(min-in),以提供一些异步特性,不要直接生成这个类的对象; ForkingTCPServer/ForkingUDPServer &emsp;ForkingMinIn与TCPServer的组合/ForkingMinIn 与 UDPServer的组合; BaseRequestHandler &emsp;无法创建这个类的实例，可以使用 StreamRequestHandler 和 DataStreamRequestHandler 创建类的实例； StreamRequestHandler/DataStreamRequestHandler &emsp;tcp请求处理类的一个实现/udp请求处理类的一个实现; socket线程池附表socket属性模块 服务器端套接字*通用函数 函数名 函数名 s.bind() 绑定地址（host,port）到套接字，在AF_INET下,以元组（host,port）的形式表示地址 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了 s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来客户端套接字 s.connect() 主动初始化TCP服务器连接，一般address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误 s.connect_ex() 函数的扩展版本,出错时返回出错码,而不是抛出异常 &emsp;&emsp;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建基于hexo的github博客系统]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84github%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文以windows为生产环境，介绍以github为免费仓库和服务器，以及node.js和hexo技术为支撑免费搭建个人博客的方法。如果想让博客链接到个人域名，那就需要去单独购买域名。 1. Git安装与github仓库配置仓库配置&emsp;&emsp;Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。与常用的版本控制工具 CVS, Subversion等不同， 它采用了分布式版本库的方式， 不必服务器端软件支持。windows环境下git的安装配置以及github仓库的配置, 可参考如下博文: windows搭建git环境 2. Node.Js与Hexo安装&emsp;&emsp;Hexo使用Markdown（或其他渲染引擎）解析文章，生成静态网页, 是搭建博客环境的基础环境，hexo依赖node.js；因此，安装hexo前必须安装Node.js和Git。 2.1 下载/安装Node.js&emsp; &emsp; 去官方下载最的.msi的新可靠版本，双击安装； 2.2 下载/安装hexo&emsp;&emsp; 安装完git和node.js之后，在本地创建一个路径用来保存hexo，其实也就是自己的本地博客代码库，比如E:\github\blog；然后，打开安装的git bash切换到刚刚创建的目录，输入npm install -g hexo-cli安装hexo； 注: npm是随同Node.JS一起安装的包管理工具, 所以装好node.js就可以在git bash中使用npm工具，无需单独安装； 3. Hexo的基本配置&emsp;&emsp;Hexo 作为一个快速、简洁且高效的博客框架。在我们下载hexo后，首先要做的是初始化hexo，告诉hexo在哪里保存博客网站 初始化hexo $ hexo init [folder]，没有folder属性就默认在hexo当前的路径建立并保存网站文件。查看hexo的基本命令可以参考hexo指令； 更改hexo主题 笔者使用的next模板主题，首先切换到hexo的themes文件夹下，将主题下载下来，在hexo的文件中将原始的theme配置由landscape改为next； 1git clone https://github.com/iissnan/hexo-theme-next themes/next 部署主题 hexo路径下的git bash输入: 12hexo clean; hexo generate #清理缓存并生成文件hexo deploy #部署 配置主题 next主题的配置文件是next文件夹下的_config.yml文件 写博文 $ hexo new &lt;title&gt; 使用默认属性在source\_posts路径下，生成一个markdown文件，然后就可以在这个文件中撰写自己的博客； 4. 绑定个人域名&emsp;&emsp;购买和注册：目前国内阿里、腾讯和百度以及华为的云都有域名购买和注册的服务，笔者在腾讯云上注册了ruitear.com这个域名。一个域名一年一般几十块钱, 还提供免费的dns域名解析服务。 配置cname文件：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是ruitear.com，有且只能添加一个。 将github博客关联到自己的域名：在域名解析的地方添加三条记录，如下图所示； 注意：blog.github.io. 是我的博客仓库名；192.30.252.153,192.30.252.154是GitHub提供的IP地址。 www：解析后的域名为 www.你的域名 @：直接解析主域名 你的域名 *：泛解析，匹配其他所有域名 *.你的域名 参考文献[1] hexo中文文档：https://hexo.io/zh-cn/docs/[2] Hexo搭建的GitHub博客之优化 http://wangwlj.com/2017/09/09/blog-opti/[3] 在Github上利用hexo搭建个人博客 https://www.jianshu.com/p/9df4aba9c25a]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>blog环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python工具包之matplotlib的使用--pyplot画图]]></title>
    <url>%2F2018%2F07%2F15%2Fpython%E5%B7%A5%E5%85%B7%E5%8C%85%E4%B9%8Bmatplotlib%E7%9A%84%E4%BD%BF%E7%94%A8-pyplot%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; Matplotlib 是一个 Python 的 2D绘图库, 使用matplotlib能够非常简单的可视化数据。在matplotlib中使用最多的模块就是pyplot。pyplot非常接近Matlab的绘图实现，而且大多数的命令及其类似Matlab。在使用Matplotlib的时候需要import这个模块：1import matplotlib.pyplot as plot &emsp;&emsp;由于matplotlib默认字体没有中文，如果想让画图的标题支持中文的显示，必须手动添加中文字体方可，以下导入SimHei字体： 12from pylab import mplmpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;] &emsp;&emsp;画图的时候还会依赖数组和矩阵等科学计算，所以会对numpy产生依赖；所以还需要import numpy；下面将以线图、柱状图、饼图、极坐标图和散点图等几种典型的图表，介绍pyplot这个模块的画图功能。 1. 单个图表的线图&emsp;&emsp;画单个线图和MATLAB，其实基本是一样的，首先选择一个X轴的范围，然后在这个范围内把[x,y]在对应的坐标区间画出来。完整的代码如下：123456789101112131415## 字体的默认设置没有中文，所以需要手动添加中文字体才能显示中文from pylab import mplmpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]import numpy as npimport matplotlib.pyplot as plot##画单个图，多根线def plotSignleImg(): x=np.arange(0,5,0.2) # X轴的范围，0-5，点的间距是0.2个单位 plot.plot(x,x**4,&apos;r&apos;,x,x*90,&apos;bs&apos;,x,x**3,&apos;g^&apos;) ## &apos;r&apos;红 &apos;bs&apos;蓝 &apos;g^&apos;绿 plot.show() # 显示画图结果 if __name__==&apos;__main__&apos;: plotSignleImg() &emsp;&emsp;效果图： 2. 多个图表在一个图&emsp;&emsp;在一个图表中画多个图，合画单个图的方式基本是一致的，唯一的区别就是，画多图的时候需要把画布分割成相应的块数，来放图表。如下例子，画两个图，需要命令plot.subplot(211)和plot.subplot(212)这两行代码中的数字前边两个必须一直，最后一个数代表图的位置，这里1表示上边的位置，2表示下边的例子。 12345678910111213## 画多个图，多根线def plotMultiImg(): x1=np.arange(0,5,0.05) x2=np.arange(0,5,0.05) plot.figure(1) #启一个画布，用来承载图表的渲染，可忽略，默认会加载 plot.subplot(211) #211 2：水平方向2个图，1：垂直方向1列，1：第1个位置 plot.plot(x1,x1**4,&apos;r&apos;,x1,x1*90,&apos;bs&apos;,x1,x1**3,&apos;g^&apos;,linewidth=2.0) plot.subplot(212) # 212 2：水平方向2个图，1：垂直方向1列，1：第2个位置 plot.plot(x2,np.cos(2*np.pi*x2),&apos;k&apos;) plot.show() &emsp;&emsp;效果图： 3. 画直方图 (柱状图))&emsp;&emsp;正态分布是大家接触最多的一种数据的呈现规则；这里以正态分布为例，介绍一下怎么画一个正态分布图的直方图；首先构造一组满足正态分布的数据，取分布在[0,1]随机的1000组数据，构造正态分布数据。x=mu+sigma*np.random.randn(1000)从标准正态分布中返回n=1000个样本值，这1000个数值的大小随机在[0,1]。 123456789101112131415def plotHitImg(): mu,sigma=100,15 x=mu+sigma*np.random.randn(1000) #从标准正态分布中返回n=1000个样本值。 bins=100 plot.hist(x,bins,normed=1,histtype=&apos;stepfilled&apos;,facecolor=&apos;b&apos;,alpha=0.75) n,bins,patches=plot.hist(x,100,normed=1,facecolor=&apos;k&apos;) #k 表示黑色 b blue g green r red c cyan m magenta y yellow w white plot.xlabel(&quot;频率&quot;) plot.ylabel(&quot;概率&quot;) plot.title(&quot;直方图示例&quot;) plot.text(40,0.028,&apos;均值=100 标准差=15&apos;) plot.axis([40,160,0,0.03]) plot.grid() plot.show() 这里plot.hist()函数中， bins将直方图的取值范围进行均等划分bings个区间； normed =1 表示将出现频次进行了归一化。 normed=0，则为频次； alpha表示直方图的透明度[0, 1] ； histtype = ‘stepfilled’ 表示去除条柱的黑色边框 , hist柱子类型 rwidth= :柱子与柱子之间的距离，默认是0 orientation:水平或垂直方向 plot.text()函数中， text(x,y,string,fontsize=15,verticalalignment=”top”,horizontalalignment=”right”) x,y:表示坐标值上的值 也就是字符串在图标的位置； string:表示说明文字 fontsize:表示字体大小 verticalalignment:垂直对齐方式，参数:[center|top|bottom|baseline] horizontalalignment:水平对齐方式，参数:[center|right|left] &emsp;&emsp;效果图： 4. 画饼图&emsp;&emsp;饼图，在分析数据时，主要呈现各份数据在总体的比例；相同颜色的数据标记组成一个数据系列。）显示为整个饼图的百分比。这里简单用水果的例子示意，总共有苹果、西瓜、猕猴桃和芒果等四种水果。它们分别占50%、12%、20%和18%。123456789def plotPieImg(): labels=[&apos;苹果&apos;,&apos;西瓜&apos;,&apos;芒果&apos;,&apos;猕猴桃&apos;] size=[50,12,18,20] explode=(0,0.0,0,0) plot.pie(size,explode=explode,labels=labels,autopct=&apos;%1.1f%%&apos;,shadow=True,startangle=90,pctdistance = 0.6) plot.axis(&apos;equal&apos;) plot.legend() #画出标签的图 plot.show() pyplot.pie()函数：patches,l_text,p_text = atplotlib.pyplot.pie() 参数 默认值 描述 x NA 数组。输入的数据用于创建一个饼图。 explode None 数组，可选参数，维度为数据项的个数，如explode=(0,0.5,0,0) 第二个突出 labels None 列表,可选参数，为每个饼块的标记。维度为数据项个数。 colors None 数组,可选参数，用来标注每块饼图的颜色。None：将使用当前活动环的颜色。 autopct None 字符串或函数，可选参数。如果不是None，是一个字符串或函数用带有数值饼图标注。 pctdistance 0.6 浮点数,可选参数,每个饼切片中心和通过autopct生成的文本开始之间的比例。如autopct是None,被忽略。 shadow False 布尔值，可选参数，在饼图下面画一个阴影。 labeldistance 1.1 浮点数，可选参数，被画饼标记的直径。 startangle None 浮点类型，可选参数，如果不是None，从x轴逆时针旋转饼图的开始角度。 radius None 浮点类型，可选参数，饼图的半径，如果半径是None，将被设置成1。 counterclock rue 布尔值，可选参数，指定指针方向，顺时针或者逆时针。 wedgeprops None 字典类型,可选参数,参数字典传递给wedge对象用来画一个饼图.如：wedgeprops={‘linewidth’:3}线宽为3。 textprops None 字典类型，可选参数，传递给text对象的字典参数。 center (0, 0) 浮点类型的列表，可选参数，图标中心位置。 frame False 布尔类型，可选参数，如果是true，绘制带有表的轴框架。 rotatelabels False 布尔类型，可选参数，如果为True，旋转每个label到指定的角度。 hold None data None 返回值：patches：列表。matplotlib.patches.Wedge实例列表。text：列表。matplotlib.text.Text实例label的列表。autotexts：列表。A是数字标签的Text实例列表。 仅当参数autopct不为None时才返回。 &emsp;&emsp;效果图： 5. 极坐标图&emsp;&emsp;先简单说一下极坐标系：在平面内取一个定点O，叫极点，引一条射线Ox，叫做极轴，再选定一个长度单位和角度的正方向（通常取逆时针方向）。对于平面内任何一点M，用ρ表示线段OM的长度（有时也用r表示），θ表示从Ox到OM的角度，ρ叫做点M的极径，θ叫做点M的极角，有序数对(ρ,θ)就叫点M的极坐标，这样建立的坐标系叫做极坐标系。通常情况下，M的极径坐标单位为1（长度单位），极角坐标单位为rad（或°）。[参考 极坐标]。因此，画极坐标图，我们需要先建一个极坐标系，ax=plot.subplot(111,projection=&#39;polar&#39;)利用subplot函数在当前的figure中建立一个极坐标系，返回针对这个subplot的一个坐标轴Axes对象。然后设置这个subplot的bar，bar(left, height, width=0.8, bottom=None, **kwargs)设置一个矩形框，大小限定在left, left+width, bottom, bottom+height的范围，left，bottom，height，width四个参数决定位置和大小left决定了左边界，bottom决定了下边界，height决定了长度，width决定了宽度。对应到笛卡尔坐标系中，left决定了扇形的中线位置，然后height决定扇形的长度，bottom决定了下边界，width决定了扇形的宽度。 numpy中random.rand()和randn() random.randn(d0, d1, …, dn)是从标准正态分布中返回一个或多个样本值 numpy.random.rand(d0, d1, …, dn)的随机样本位于[0, 1)中 1234567891011121314#面向对象的极坐标图绘制def plotPolorImg(): N=20 theta=np.linspace(0.0,2*np.pi,N,endpoint=False) #角度 radii=10*np.random.rand(N) # 随机20个[0,10]的样本 width=np.pi/4*np.random.rand(N) 随机20个[0,1]*2pi的样本，也就是 ax=plot.subplot(111,projection=&apos;polar&apos;) #建立一个坐标系，projection=&apos;polar&apos;表示极坐标 bars=ax.bar(theta,radii,width,bottom=0.0) #绘制一个条形图 #theta,radii,width分别是left，height， width for r,bar in zip(radii,bars): #循环为每个bar对象设置颜色和透明度 bar.set_facecolor(plot.cm.viridis(r/10.)) bar.set_alpha(0.5) #添加颜色 plot.show() zip()函数 将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。zip 方法在 Python2和 Python 3 中的不同：在 Python3 中为了减少内存，zip()返回的是一个对象。如需展示列表，需手动 list() 转换。bar.set_facecolor() 窗口的背景颜色bar.set_edgecolor() 窗口的边框颜色plot.cm.viridis() 蓝-绿-黄colormapset_alpha() 设置透明度，同plot的alpha参数，透明度[0, 1]alpha表示直方图的透明度[0, 1] ； &emsp;&emsp;效果图： 6. 散点图&emsp;&emsp;散点图，顾名思义就是在图中分布的各个没有连接的孤点，也就是把某些点在坐标中明晰的表示出来。在数据的二维和三维表示中，用来发现数据分类和排布很有作用。1234567#散点图def plotScatterImg(): #返回值 fig : matplotlib.figure.Figure object ax : Axes object or array of Axes objects. fig,ax=plot.subplots() ax.plot(10*np.random.rand(10),10*np.random.rand(10),&apos;o&apos;) ax.set_title(&apos;简单散点图&apos;) #设置图标标题 plot.show() &emsp;&emsp;效果图： 参考附表python的颜色图谱(colormap), 例如在matplotlib.pyplot.imshow(X, cmap=None)中 X: 要绘制的图像或数组； cmap: 颜色图谱（colormap), 默认绘制为RGB(A)颜色空间。 颜色图谱 描述 颜色图谱 描述 row 1 col 1 row 1 col 2 hsv hsv颜色空间， 红-黄-绿-青-蓝-洋红-红 row 2 col 1 row 2 col 2 inferno 黑-红-黄 autumn 红-橙-黄 jet 蓝-青-黄-红 bone 黑-白，x线 magma 黑-红-白 cool 青-洋红 pink 黑-粉-白 copper 黑-铜 plasma 绿-红-黄 flag 红-白-蓝-黑 prism 红-黄-绿-蓝-紫-…-绿模式 gray 黑-白 spring 洋红-黄 hot 黑-红-黄-白 summer 绿-黄 viridis 蓝-绿-黄 winter 蓝-绿 学习文献[1] 官方教程 : https://matplotlib.org/users/pyplot_tutorial.html[2] matplotlib详细介绍 https://blog.csdn.net/sunshine_in_moon/article/details/46573117[3] matplotlib基础绘图函数示例 https://www.jianshu.com/p/ad14fee5fb60[4]matplotlib极坐标方法详解 https://www.cnblogs.com/kallan/p/6738577.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>plot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows搭建git环境]]></title>
    <url>%2F2018%2F07%2F14%2Fwindows%E6%90%AD%E5%BB%BAgit%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。与常用的版本控制工具 CVS, Subversion等不同，它采用了分布式版本库的方式，不必服务器端软件支持. 1. git安装&emsp;&emsp;下载git windows一路安装下来. 2. 注册github账户&emsp;&emsp;访问github官网，注册一个github账户. 3. git bash添加本地仓&emsp;&emsp;通过 git bash 客户端添加添加一个本地文件夹作为本地仓库；可以通过 pwd 命令来查看当前bash窗口的路径。&emsp;&emsp;此处静载本地f盘创建了一个git的空文夹名为:git，用来作为本地的仓库。然后，cd到git文件夹下，用git init命令初始化这个文件夹。&emsp;&emsp;初始化之后，再调用 git config --global config 本地仓库关联到远端的 github 账户，也就是你注册 github 的时候填的用户名和邮箱。&emsp;&emsp;到这里，其实已经基本建好了本地仓库和远程github仓库的连接。但是每次使用的时候都让你输入用户名和密码，很是麻烦。怎么解决呢？添加 ssh key， 可以根据官网的 git help 创建ssh秘钥。这里首先调用 $ ssh-keygen -t rsa -C &quot;liuru@host.com&quot; 调用创建秘钥的指令。&emsp;&emsp;如上图所示，使用默然的方式生成，并没有进行设置，密码根据自己的喜好设置。然后一直enter到末尾，有了这个秘钥之后，我们还需要做两件事情：1、把这个密码和github账户关联起来；2、把它和本地客户端关联起来。 关联的到github账户: 在github账户的setting地方有一个ssh key的你添加输入，生成的秘钥内容（id_rsa.pub文件中保存），到相应的地方即可; 关联本地客户端: 根据上述创建的过程中的提示，我们找到相应的.ssh/id_rsa.pub找到文件。首先确保ssh客户端能用，调用 evel &quot;$(ssh-agent -s)&quot; 命令查看, 有 agent id 即为有用； 然后, 调用 ssh-add ~/.ssh/id_rsa 把秘钥添加到ssh客户端，这样整个过程就创建完成，就可以享受git带来的便利了。4. 从github仓库clone内容&emsp;&emsp;在本地创建了一个与github的账号同名的文件夹，比如我的github上有一个仓库叫C-Cplus-plus的仓库，然后调用 $ git clone git@github.com:ruitear/C-C-plus-plus.git (其中ruitear是账户名)5. 在仓库里面创建子文件夹&emsp;&emsp;陆github账户在网页上只能以单个文件的形式进行upload，然而并不符合我们管理文档的习惯，建立文件夹来管理文档和代码是我们必须的，为此，就需要进行添加文件夹的操作，cd到相应的版本仓库的本地文件夹，调用$ git add Sort/ . 这样就在C-Cplus-plus仓库内添加了一个Sort文件夹，当然这并不是最终形式没还需要commit操作才能生效, 也就是保存到本地仓库：$ git commit -m &quot;相关说明&quot;&emsp;&emsp;最后调用push把添加之后的仓库push到github仓库了 $git push origin master ， 到这里就完成了git本地环境的搭建并与github创建了相应的连接。【注意】，当我们往已经有的仓库中添加新的代码时记得，先pull下来更新代码赖，然后在push，如果有冲突就解决冲突，没有的话就直接push。]]></content>
      <categories>
        <category>git使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
</search>
