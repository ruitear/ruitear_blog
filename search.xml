<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NR PDSCH资源分配]]></title>
    <url>%2F2021%2F06%2F25%2FNR-PDSCH%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1. PDSCH频域资源分配PDSCH频域资源分配方式有两种，称为type0和type1，支持动态和静态配置；动态配置由DCI进行指示，而静态配置通过IE pdsch-Config中参数resourceAllocation指示，如下图所示； 1.1 终端如何获取频域资源分配方式的信息 如果终端通过DCI 1_0接收调度，那么只能是Type 1； 如果终端通过DCI 1_1接收调度，需要参考RRC参数配置决定。通过基站在pdsch-Config中配置resourceAllocation来指示UE采用哪种频域资源分配方式，如上表PDSCH-Config所示。如果配置的是dynamicSwitch，UE需要借助DCI中Frequency domain resource assignment的MSB这个bit来判定这次调度是type0还是type1。如果是resourceAllocationType0或者resourceAllocationType1，配的什么就用什么； 1.2 RB资源起始和RBG size的确定 RB起始的确定：UE在检测到预期用于UE的PDCCH时将首先确定下行载波BWP，然后确定BWP内的资源分配。如果在DCI中未配置BWP指示符字段或者UE不支持由DCI改变激活BWP，那么在UE激活的BWP内确定用于下行type0和type1资源分配的RB索引。如果DCI中配置了BWP指示符字段并且UE支持由DCI改变激活BWP，则DCI中BWP指示符字段的值指示的UE的BWP内确定用于下行type0和type1资源分配的RB索引。对于PDCCH CSS中由DCI_1_0调度的PDSCH，无论哪个激活BWP，RB编号从接收DCI的CORESET的最低RB开始；否则，RB编号从所确定的下行BWP中的最低RB开始。 RBG Size的确定：其由IE PDSCH-Config中参数rbg-Size和当前的BWP带宽决定，如下图所示：rbg-size确定配置类型是configuration 1还是configuration 2，然后再根据当前BWP的大小确认RBG Size。 RBG个数的确定在协议中有如下的定义： 1.3 type0和type1的频域资源分配 Type0：是一种频域资源非连续分配的方式，相对灵活：使用bitmap来指示用于分配给终端的频域资源，1表示分配，0表示未分配。每个bit代表一个RBG，RBG是的大小和两个因素相关，一个是当前BWP的大小，二是参数rbg-Size是Configuration 1还是Configuration 2。RBG的index在频域上是从BWP的low frequency向high frequency来计数； Type1：是一种频域资源连续分配的方式：使用RIV的方式告知终端所分配RB的起始位置RB_start和分配了多少个连续的RB，即L_RB；【38214的5.1.2.2.2有RIV计算的过程】。RB_start和L_RB的使用范围：对于DCI 1_0 common search space的情况，此时使用CORESET0的大小 (if CORESET0 configured)或者初始BWP大小(if CORESET0 not configured)；对于其他情况使用当前BWP的大小。 终端在收到DCI后，通过其中的的Frequency domain resource assignment这个字段根据结合当前的配置类型，来选择通过Bitmap还是RIV的方式计算到底分配了哪些RB资源。DCI中的Frequency domain resource assignment实际是一串指示rbg或者RB的bitmap或者RIV值。协议中关于Frequency domain resource assignment的描述如下图所示， 2. PDSCH时域资源分配终端需要获取的PDSCH时域资源信息主要有3个，分别是：K0、起始symbol和长度和Mapping TypeA/B；其中：K0是终端接收到PDCCH DCI调度信息到真正接收PDSCH数据的时间间隔，单位为slot；起始symbol和长度指的是终端需要知道在所调度的slot内那些symbol是属于分配给自己的；Mapping TypeA/B是slot内symbol映射的类型。 2.1 终端如何获取配置K0、起始symbol和长度和Mapping TypeA/B 通过DCI_1_0/DCI_1_1获取 ：在DCI_1_1中，有一个Time domain resource assignment字段, 有0、1、2、3或4bit信息，确定表5.1.2.1.1-2/3/4/5的行索引Row index，协议中的描述如下： Time domain resource assignment – 0, 1, 2, 3, or 4 bits as defined in Clause 5.1.2.1 of [6, TS 38.214]. The bitwidth for this field is determined as log2 (I) bits, where I is the number of entries in the higher layer parameter pdsch-TimeDomainAllocationList if the higher layer parameter is configured; otherwise I is the number of entries in the default table. 协议38214中表5.1.2.1.1-2/3/4/5给出了PDSCH的时域信息配置表，可以通过row index去获取，表格信息如下图所示： 通过pdsch-ConfigCommon或pdsch-Config配置的pdsch-TimeDomainAllocationList获取时域信息，这个参数组中包含多组{K0，mappingType, startSymbolAndLength}的参数组，其中startSymbolAndLength是以SLIV的形式给出的，可以计算出Start Symbol和Length，下图是配置的示例： SLIV具体计算过程在38214-5.1.2.1中介绍，通过TimeDomainAllocationList获取时域信息参数组，结合SLIV的计算公式和有效的SLIV的约束表38_214_5_1_2_1-1，可以计算出起始符号和长度分别是多少。 例如：上图中SLIV是54，其中映射类型是typeA，使用normal cp在，遍历可以计算得到S=1，L=12。SLIV对应的SL表格，可通过如下链接查看获取5G-SLIV. 2.2 什么时候使用DCI或者RRC配置获取时域pdsch信息PDSCH的时域资源是根据DCI format 1_0/ DCI format 1_1中Time domain resource assignment字段进行确定。其中Time domain resource assignment的bits数取决于RNTI、PDCCH搜索空间以及高层是否在IE pdsch-ConfigCommon或pdsch-Config中配置pdsch-TimeDomainAllocationList相关；如果pdsch-ConfigCommon或pdsch-Config中配置了pdsch-TimeDomainAllocationList，则UE采用pdsch-TimeDomainAllocationList进行时域资源的确定，否则UE根据RNTI、PDCCH搜索空间等信息采用默认的时域资源表进行查表也就是38214中表5.1.2.1.1-2/3/4/5。通过字段Time domain resource assignment的值m用于确定时域资源分配表中的行索引m+1。 pdsch-ConfigCommon中的配置适用于c-rnti或者cs-rnti加扰的pdcch，不适用于38214表5.1.2.1.1-1中默认值的coreset#0； 如果pdsch-TimeDomainAllocationList被配置，那么DCI中Time domain resource assignment的字段宽度就由他确定，DCI中value 0,对应pdsch-TimeDomainAllocationList中的第一个元素，value 2对应第二个，一次类推，其中maxNrofDL-Allocations为16，也就是Time domain resource assignment最大是4bit。 如果pdsch-TimeDomainAllocationList没有被配置，那么Time domain resource assignment的bit数由38214表5.1.2.1.1-2/3/4/5确认，默认是4bit。 例1：如果UE在PDCCH的Type0A common搜索空间中搜到了由SI-RNTI加扰的PDCCH，S/PBCH block and CORESET multiplexing pattern 是2，那么查表38214-5.1.2.1.1-1，如下，可以得到需要查default B的表，也就是表38214-5.1.2.1.1-4，根据DCI的Time domain resource assignment确定Row Index，然后找到对应的PDSCH时域资源信息。 例2：如果UE在UE specific 搜索空间中搜到了由C-RNTI加扰的PDCCH，其中pdsch-ConfigCommon 包含 pdsch-TimeDomainAllocationList，pdsch-Config中包含了 pdsch-TimeDomainAllocationList，那么pdsch-Config中的pdsch-TimeDomainAllocationList的配置将覆盖pdsch-ConfigCommon中的。从表38214-5.1.2.1.1-1中可以得知，DCI中Time domain resource assignment字段值指示的是pdsch-Config中的pdsch-TimeDomainAllocationList的索引，从而得到PDSCH时域资源{k0，mapping type， sliv}信息对，通过其中SLIV通过上述的反推方式可以计算出psdch的起始符号和符号长度。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PDSCH的MCS选择与码率确定以及TBsize的计算和RB预估]]></title>
    <url>%2F2021%2F05%2F21%2FPDSCH%E7%9A%84MCS%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A0%81%E7%8E%87%E7%A1%AE%E5%AE%9A%E4%BB%A5%E5%8F%8ATBsize%E7%9A%84%E8%AE%A1%E7%AE%97%E5%92%8CRB%E9%A2%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[1. mcs的选择和码率的确定对月PDSCH的调度，主要有两种方式的一种是有PDCCH并通过C-RNTI, MCS-C- RNTI, TC-RNTI, CS-RNTI, SI-RNTI, RA-RNTI, 或者 P-RNTI加扰，下发DCI_1_0或者DCI_1_1来调度；另一种是在没有PDCCH的情况下通过高层提供的SPS-Config配置来进行PDSCH调度。PDSCH调制阶数通过DCI中5bit的字段I_MCS来指数，5bit最大32，协议中定义了3张mcs表，分别是1个256QAM，2个64QAM的表；在不同的场景选用不同的mcs表。比如UE不希望在解码P-RNTI, RA-RNTI, SI-RNTI加扰的PDSCH时，使用Qm &gt; 2的调制方式。 case1： 高层配置PDSCH-config种使用qam256的mcs表，那么对DCI1_1指示的PDSCH使用Table 5.1.3.1-2来确定MCS和码率，也就是256qam的表格。 case2： 如果UE没有通过SPS-config来配置mcs表，而是通过pdsch-config配置了成qam256，那么UE使用Table 5.1.3.1-2来确定MCS和码率，也就是256qam的表格。 case3： 如果UE没有配置MCS-C-RNTI，且高曾参数pdsch-config种配置的mcs表是qam64LowSE，那么针对UE USS 搜索空间的对应的PDSCH调度使用Table 5.1.3.1-3来确定MCS和码率，也就是低码率的64qam的表格。 case4： 如果UE配置了MCS-C-RNTI，pdsch是被MCS-C-RNTI加扰的PDCCH指示调度，那么UE使用Table 5.1.3.1-3来确定MCS和码率； case5： 如果UE的mcs表通过SPS-Config配置并且配置成qam64LowSE，那么UE使用Table 5.1.3.1-3来确定MCS和码率； case6：除了上述5种情况外，使用Table 5.1.3.1-1；从上述的mcs表种可以看出，当mcs确定之后相应的传输码率就确定了。因此码率是通过mcs查表间接确认得到的。 2. TBsize的计算和RB预估pdsch传输的tbsize宏观上见与码字数和码率强相关，码字由基站高层参数maxNrofCodeWordsScheduledByDCI指示，表示使用1个码字还是两个码字；码率由上mcs表确定，针对64qam可以使用mcs 0-28；256qam可以使用0-27； 2.1 TBsize的计算一个slot对应的PDSCH可用的TBSIZE计算公式如下，在PDSCH可用的RE是上除去DMRS占用和PDCCH占用的RE等资源占用以后的频谱资源。一个slot种pdsch的有效RE数由如下公式获得： 其中：N ^{RB}_{sc}是一个RB的子载波个数，N^{sh}_{symb}是时域上一个slot对应的符号数,N^{PRB}_{DMRS}是一个RB上DMRS占用的RE数；N^{PRB}_{oh}在高层参数PDSCH-ServingCellConfig-&gt;xOverhead配置，可配置为0，6，12，18；当xOverhead没有配置或者调度pdsch的pdcch由SI-RNTI, RA-RNTI 或者 P-RNTI加扰时，N^{PRB}_{oh}是0。一个slot内频域上所有的pdsch可用RE，由以下公式获取：$$\begin{equation}N_{RE} = min(156, N^{‘}{RE})*n{prb}\end{eqnarray}$$其中，n_{prb}是slot内可分配的PRB数。 有了RE数解可以计算当前的TB-Size了，TB-Size的计算如下： $$\begin{equation}N_{info} = N_{RE}RQ_{m}*v\end{eqnarray}$$其中，R是目标码率，Qm是调制阶数，V标识layer数。 有了N_info之后还需要跟3824作量化比较才能确认最终的tbsize： N_info &lt;= 3824 : 在N_info的小于3824的场景下确定TB-Size需要先量化，然后再查表确认TB-Size;量化公式如下： $$\begin{equation}N^{‘}{info} = max(24, 2^{n}*⌊\frac{N{info}}{2^n} ⌋)，其中 n = max(3, ⌊ log_2(N_{info})⌋-6)\end{eqnarray}$$通过量化公式获得的N_&#39;_info在Table 5.1.3.2-1中查找不小于他的最接近的值，比如算出来的量化值是606，那么通过查表就获得的TB-Size就是608； N_info &gt; 3824 : $$\begin{equation}N^{‘}{info} = max(3840, 2^{n}*round(\frac{N{info}-24}{2^n} ))，其中 n = ⌊ log_2(N_{info}-24)⌋-5)\end{eqnarray}$$ 当码率R&lt;=1/4时，$$\begin{equation}TBS = 8C ⌈(\frac{N^{‘}{info}+24}{8*C})⌉-24,其中C=⌈\frac{N^{‘}{info}+24}{8424}⌉\end{eqnarray}$$ 当码率R&gt;1/4时，(1) 如果N_&#39;_info&gt;8424, 那么TBS通过以下公式计算：$$\begin{equation}TBS = 8C (\frac{N^{‘}{info}+24}{8*C})⌉-24,其中C=⌈\frac{N^{‘}{info}+24}{3816}⌉\end{eqnarray}$$(2) 如果N_&#39;_info&lt;=8424, 那么TBS通过以下公式计算：$$\begin{equation}TBS = 8C (\frac{N^{‘}_{info}+24}{8})-24\end{eqnarray}$$需要注意的是：(1) 当调度PDSCH的PDCCH是通过SI-RNTI加扰的话，也就是传输sib1消息时，TB-Size的大小不能超过2976，因为sib1只能通过qpsk的调制方式发送；(2) 当调度的DCI是P-RNTI、RA-RNTI加扰的时候，在信息量N_info计算时需要带上一个缩放因子，具体如下图所示：那么新的N_info计算公式就编程如下的样子：$$\begin{equation}N_{info} = SN_{RE}RQ_{m}v, 其中S是缩放因子$$ 2.2 RB预估UE进行上下行数传的时候，基站根据UE的数据量来判断UE的调度时刻使用的RB数，数据量的计算公式如下：`$$\begin{equation}数据量 = {N_{prb}N_{re}layerQmCodeRate},$$N_prb是传递这些数据量需要的RB数，N_re是每个RB中有效的RE数，layer是数传的UE的rank，QM是调试bit数，CodeRate是传输的码率。 预估RB就是通过上边的公式反算UE传输当前数据量需要的RB数，在确定RB数之前需要先确定，每个RB中的RE数，这些RE数跟基站的配置相关，特别是PDCCH和PDSCH DMRS的配置。 PDSCH DMRS : NR中定义了两种DMRS type，分别是type1和type2，在这两种type中，有1符号或者2符号的DMRS，除此之外还可以配置额外的附加导频的DMRS。 PDSCH DMRS Type A ：固定在第三或(pos2)者第四(pos3)个符号上，无论PDSCH的起始符号是多少，最小资源组是一个RE； PDSCH DMRS Type B ：DMRS固定在分配PDSCH的第一个符号上；最小资源组是2个RE； 附加导频 ，可以配置0-4个 【参考文献】：https://www.sharetechnote.com/html/5G/5G_PDSCH_DMRS.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[5G基础-上行调度的BSR]]></title>
    <url>%2F2021%2F05%2F20%2F5G%E5%9F%BA%E7%A1%80-%E4%B8%8A%E8%A1%8C%E8%B0%83%E5%BA%A6%E7%9A%84BSR%2F</url>
    <content type="text"><![CDATA[BSR是一种从UE到网络的MAC CE；它承载有关UE缓冲区中有多少数据要发送出去的信息，用来申请上行带调度资源通知基站需要多少资源； 1. BSR的配置和内容UE可以建立多个无线承载，每个承载对应一个逻辑信道，如果每个逻辑信道都上报一个BSR，会产生大量的开销，基于这种考虑就引入了逻辑信道组的概念LCG，将逻辑信道放到逻辑信道组中，UE基于LCG来上报BSR，而不是为每个逻辑信道上报BSR，这样把相似的逻辑信道放到一个LCG中，优化了BSR上报的机制。如何划分LCG是基站根基算法实现，这里不讨论。逻辑信道的配置在LogicalChannelConfig-&gt;logicalChannelGroup中配置。 在logicalChannelConfig中的参数logicalChannelSR-Mask需要注意一下，这个参数仅针对常规BSR有效，当UE触发一个常规BSR，且已经配置了上行授权同时该逻辑信道的logicalChannelSR-Mask为true，那么就不需要发送SR。如果logicalChannelSR-Mask为false，则需要发送SR；对应到每个MAC实体的bsr-config如下图所示： 从配置中可以看到BSR-Config有几个定时器相关的参数，分别是： [1] retxBSR定时器，重传定时器是为了避免UE一直发BSR而得不到UL Grant的情况； [2] periodicBSR定时器，周期性检查UE的BSR，避免由于其他条件不满足导致UE的BSR得不到调度的情况； [3] logicalChannelSR-DelayTimer，表示在logicalChannelSR-DelayTimerApplied的启用的逻辑信道的SR传输延时定时器；如果逻辑信道配置了logicalChannelSR-DelayTimerApplied，在触发常规BSR时，会启动或者重启logicalChannelSR-DelayTimer；如果没有配置logicalChannelSR-DelayTimerApplied，在没有上行调度资源来传输新传数据时会触发SR； BSR通过MAC层的MAC CE上报，NR定义了有4种类型的BSR MAC CE，分别是: 短BSR/短截断BSR，长BSR/长截断BSR。一个BSR MAC CE与一个对应一个MAC subheader，也就是对应的LCID值，对应关系如下表所示： 需要注意的是LCID和LCG不是一个概念，LCID是MAC PDU对应的逻辑信道号。 短BSR和短截断BSR，只上报一个LCG的BSR，长度固定为8bit，并有一个长度为3bit的LCG ID字段和一个长度为5bit的buffer Size字段组成。如下图所示： 长BSR/长截断BSR可以上报一个或者多个LCG的BSR，长度不固定，如下图所示，LCG ID有3bit的字段，最多可以上报8个LCG，其值对应LogicalChannelConfig-&gt;logicalChannelGroup；图中的LCG序号标识对应编号的逻辑信道是否存在buffer size，如果改字段设置为1，则表明该编号对应的逻辑信道有BSR；否则没有；其中buffer size，长度8bit，是LCG所有逻辑信道的RLC和PDCP中剩余的可用于上行的有效传输数据综合，以byte为单位，不计算RLC和MAC的数据头。 长/短BSR的buffersize分别是8bit和5bit，那么他们要给基站的参考数据量有下标定义给出一个大概的范围，表中的buffer size value作为基站分配合适上行资源的参考，并不表示一定能给UE分出来这么多。 2. BSR分类协议中定义了三种类型的BSR：分别是Regular BSR，Periodic BSR和Padding BSR。三种BSR场景下适配长短BSR关系主要根据要发的LCG数量和响应的传输bit决定，对应关系如下图所示：]]></content>
  </entry>
  <entry>
    <title><![CDATA[5G基础--SR]]></title>
    <url>%2F2021%2F05%2F16%2F5G%E5%9F%BA%E7%A1%80-SR%2F</url>
    <content type="text"><![CDATA[1. SR(Scheduling Request))SR是UE的调度请求，用在UE像基站申请上行数据的新传调度,通过PUCCH传输，有些格式的PUCCH格式可以携带SR有些则不行。不是每次都能不一定能申请到PUCCH资源，只有UE处于RRC Connected状态且保持上行同步的UE才会发送SR； 2. SR的配置在基站中SR的配置在SchedulingRequestResourceId IE中定义了SR资源的数量，最大8个SR资源，对应的SchedulingRequestResourceId就是0-7 ；MAC的配置中， 逻辑信道可以分别关联SR配置，一个MAC实体可以配置0个、1个或者多个SR配置，不同的逻辑信道可以关联相同的schedulingRequestID，如果没有给相应的逻辑信道配置SR，当该逻辑信道有数据发送时只能通过随机接入获得上行调度。一个mac实体通过MAC-CellGroupConfig-&gt;schedulingRequestConfig-&gt;schedulingRequestToAddModList配置一个SR列表。其中每个SR配置对应一个schedulingRequestConfig； 一个SR配置(SchedulingRequestConfig)包含了分布在不同bwp或者小区中用于传输SR的一组PUCCH资源，也就是SR资源，目前SR只支持PUCCH format0或者PUCCH format1. 从协议38.331的描述可以看到一个SchedulingRequestConfig中对应一组SchedulingRequestResourceConfig，也就是一个SR配置可以对应多个SR资源，他们实际使用是分布在不同的小区或者BWP上。在特定逻辑信道上，每个BWP最多配置1个用于SR的PUCCH资源。 上行BWP通过BWP-UplinkDedicated-&gt;pucch-Config-&gt;schedulingRequestResourceToAddModList配置一个SR资源表，每个SR资源对应一个SchedulingRequestResourceConfig，这个SR资源有一个schedulingRequestID指示它被哪个SR配置使用，schedulingRequestID 是区分不同的SR配置的唯一值，关联了sr-ProhibitTimer和sr-TransMax。通过BWP与小区的对应关系，可以确定一个SR配置在特定小区的特定上行BWP上使用的SR资源。 在pucch-config中为各个上行bwp配置了sr资源，使用schedulingRequestResourceId来区分不同的资源配置，schedulingRequestResourceId会关联schedulingRequestID，还包括SR发送时间点配置，以及对应的pucch resource配置。 下图是SR在接入过程的对逻辑信道的配置的示例，信令中对SRB1/SRB2/DRB都配置了响应的相同的SR资源。 3. SR的发送针对每个SR资源，基站通过SchedulingRequestResourceConfig-&gt;resource告诉UE使用PUCCH format0还是 format1来发送SR。 在SchedulingRequestResourceConfig中的periodicityAndOffSet字段指定传送SR的PUCCH资源的周期,以符号或者slot为单位，确定了SR的发送时间位置[TS38.331 9.2.4]。可以看到SR的最小周期是2符号。基于SR周期的差异，把SR对应三种场景来，如下图case所示： 从协议指示的配置范围可以看出，根据不同的子载波间隔，可选择的周期偏移有所不同；当UE发现一个SR传输机会对应PUCCH资源所在的slot，用于改pucch传输的符号数小于对应pucch资源所需的符号数，UE不会在该slot上发送pucch资源；SR资源是UE专用，UE发送SR时不需要指定自己的CRNTI，基站通过SR资源的时域、频域和码分复用信息就知道哪个UE请求上行资源。 协议描述中有Positive SR和Negative SR的概念，UE并不是一直有发送SR请求的需求，对于Positive SR即UE有SR请求发送，需要物理层发送SR/PUCCH，而对于无SR发送请求的UE，在SR资源的时间点，则该SR为Negative SR。基站不知道UE什么时候发送SR，需要在已经分配的SR资源上检测是否有SR上报，会在每个SR上来的时刻监测是否有SR资源，具体的SR调度流程如下图所示：SR调度流程注意事项： 只有在pucch资源上配置了SR才能发送SR请求上行调度，不然只能通过随机接入申请上行资源； SR发送实际在PUCCH的特定位置，以便基站能检测到SR； SR发送实际不能和测量GAP重合； 如果sr-ProhibitTimer未超时，则不能发送SR，此时定时器放置SR发送过多，降低PUCCH负载； 当UEUESR的传输实际和测量gap重叠或者sr-ProhibitTimer未超时等原因不能发送SR时，需要循环检测，指导条件满足； SR-COUNTER为计数器，只有当SR-COUNTER&lt;sr-TransMax时，才能发送。为了放置SR重传发送过多，当SR成功触发UL GRANT后，SR-COUNTER会置零； UE触发SR后，这个SR级处于pending态，意思是为UE准备单是还没有发送SR，如果已经准备发送BSR，或者PUSCH资源足够，那么pending的SR会被取消。 UE发送SR之后，无法确定基站什么时候会下发UL Grant，如果UE等待超时（由果sr-ProhibitTimer定时器配置）就会尝试重发SR，每个SR都有自己的果sr-ProhibitTimer当SR请求发送达到最大次数仍然不能获得上行调度后，通过发送PRACH触发随机接入过程来获得上行调；当SR的到达最大发送次数后无上行调度，除了发送PRACH外，MAC执行的操作还包括： 1.通知RRC Release所有服务小区PUCCH配置; 2.通知RRC Release所有服务小区SRS配置; 3.清除Configured DL assignments和 Configured UL Grants. 4.清除用于发送semi-persistent CSI的PUSCH Resource.]]></content>
  </entry>
  <entry>
    <title><![CDATA[LTE和NR共存之动态频谱共享]]></title>
    <url>%2F2021%2F04%2F30%2FLTE%E5%92%8CNR%E5%85%B1%E5%AD%98%E4%B9%8B%E5%8A%A8%E6%80%81%E9%A2%91%E8%B0%B1%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1. 背景5G频谱在全球各国进行的划分，以主力中低频段主力，中频段主要是TDD，低频段与原有的LTE频谱共用。图1-1是目前主要国家的频谱划分。 图1-1 全球主要国家的5G频谱 频段的分配上，TDD是5G部署的主流，特别是亚太的中日韩地区；在5G部署的初期，TDD制式的主流的设备基本部署在以3.5G为主的频段上，没有历史的遗留问题要解决；但是并不是所有的国家或者运营商都有这样的频谱；在欧美地区，中频段的频谱已经被部分占用，比如北美3.5G频谱被军用卫星占用；除此之外，3.5G的覆盖也是相对差一些，如何提升覆盖，让用户5G的信号服务更广泛的用户，是当前运营商面对的主要问题之一。频谱的价格也比较昂贵，如何复用低频段的已有频谱频谱，快速部署5G，同样也是运营商面对的主要问题。针对上述两个问题，3gpp提供了两种解决方案方法：（1）把5G部署到低频段里面与LTE共存；（2）让低频段辅助3.5G进行业务。基于运营商的困难和现实的瓶颈，各设备厂商提出了两个解决思路：（1）辅助上下行（SUL/SDL）;（2）LTE和NR共存。辅助上下行，不是这里讨论的内容；当前只关注LTE和NR共存的问题。 2. LTE和NR的动态频谱共享动态频谱共享，从名字上看，在一块特定频谱上，LTE和NR在时域或者频域上同时存在，都有业务，资源复用。就是在时域和频域上划分，概括为FDM(频分)和TDM（时分）。如下图2-1所示。 图2-1 TDM和FDM共享示意图 FDM：(1)静态分割为独立载波，频带上无LTE使用的资源；(2)在保证LTE正常的业务的情况下，将LTE原本使用频域资源的频域资源进行划分，分给NR使用； TDM：(1)分时按子帧级别共享复用，在保证LTE正常业务的情况下，将某个子帧中除了LTE使用的控制信息使用的符号外，都分给NR使用。主要分为MBSFN和non-MBSFN两种情况。 具体到LTE和NR的业务实际，该如何实现共享呢？LTE的调度最小粒度是subframe，NR的最小粒度是slot。在subframe范围内，考虑LTE和NR的共享和共存，如图2-2的所示，主要是细分为四种场景： （1）在某个subframe NR使用LTE没用的频谱； （2）在某个subframe LTE都不使用，全部由NR使用频谱； （3）在LTE的MBSFN子帧中，LTE使用部分符号，剩下的由NR使用； （4）某个subframe LTE PDSCH不调度，NR使用个别符号调度。 图2-2 LTE和NR共存是频谱共享的方式 3. 实现LTE和NR共存的方法根据运营商的实际需求和实现的系统复杂度，在3GPP R1‑1701618[1]会议的讨论如表3-1所述的5种方式；前三种Static FDM、Semi-static TDM和subframe级别的DSS(动态频谱共享)三种共享共存的方式是3gpp优先考虑的策略。第一个阶段是Static FDM，然后是Semi-static TDM，接着是subframe级别的DSS。目前这三个阶段宏站的设备厂商基本已经走完。 表3-1 动态频谱共享的实现方法 共享方式 描述 Static FDM 带宽为20 MHz，动态划分LNR使用比例，5 / 15、10 / 10或15/5 MHz分区等 Semi-static TDM 利用LTE DL MBSFN子帧和未使用的UL子帧的资源来调度NR Subframe 级别DSS 在时域上subframe级别使用LTE未使用的资源 CLI级别DSS 根据CLI mitigation of duplexing flexibility使用LTE未使用资源传输NR PRB级别DSS 在频域上在时域上子帧级别使用LTE未使用的资源 5G的制式和LTE一样，依然是TDD和FDD二分天下，由于TDD的频谱分配的先天优势，LTE和NR共存的场景和需求很少出现，而FDD因为LTE的历史频谱问题，有大量的存量网络，在网络从LTE到5G的升级换代的过程中，迫切的需要LTE和NR的频谱共享，制式共存。实现这种共享共存的技术，称为动态频谱共享，简称DSS。 图3-1 LTE和NR FDM和TDM RE级别的频谱共享示意图 根据运营商的频谱和现网的测试情况，我们看到四大主设备厂商对LTE和NR的频谱共享各有侧重，在表3-2中简要列出。 3.1 主流设备厂商的频谱共享方案表3-2 四大设备厂商的动态频谱共享场景 厂商 解决方案 TDD/FDD制式 备注 华为 Hybrid DSS TDD和FDD TDD主要考虑中移动 爱立信 Ericsson SS FDD 爱立信 Super DSS TDD和FDD TDD主要考虑中移动 诺基亚 DSS FDD 从他们针对的运行商和测试结果来看，华为和中兴的TDD方案主要针对中移动N41获得的160M 2.6G频谱的解决大带宽部署LTE和NR共存的问题。诺基亚和爱立信在FDD上的耕耘，更富热情，大量存量的low band频段是FDD的LTE网络，在进入当前网络部署的阶段，如何快速的部署5G，与LTE共存，对他们的欧洲和北美客户来说是一个需要解决的现实问题。面对客户的痛点，他们通过动态频谱共享技术， 帮助客户进行提升网络部署，拓展业务。在FDD和TDD上，他们的方案有什么具体的差异，又是如何设计解决方案的呢？ 在接下的部分，将分别介绍四大设备厂商动态频谱共享在TDD和FDD的实现技术方案，其中TDD介绍介绍华为中兴的方案；FDD介绍爱立信和诺基亚的方案。 3.2 动态频谱共享IN TDD 动态频谱共享在TDD的实现，华为和中心的方案基本差不多，在支持mimo的AAU上保证4G不移频的情况下，主要部署2.6G NR。如图3-2所示，是中兴的频谱共享方案和2.6G的演进变化。主要是预期三个阶段： 图3-2 中兴在中移动2.6G上的动态频谱共享解决方案 阶段1：在不使用LTE和NR动态频谱共享之前的，LTE大面积在网部署的时候，在2515-2575范围内，固定部署60M的NR，剩下的100M都部署LTE的载波。 阶段2：当5G进入中期部署，NR已经规模部署，还存量大量的LTE网络，在2575-2595范围的40M，根据LTE和NR的负载情况，动态部署NR和LTE的载波，进行动态频谱共享，在40M的载波中动态的建0或1或2个20M的载波。 阶段3：当NR进入连片组网，LTE网络开始进入中后期，存量下降，将频谱共享的频段完全固定作为NR带宽，保证满带宽100M的，进行整体连片100M NR的建网。 华为的方案是什么样的呢？如图3-3所示，根据LTE和NR的负载情况，动态的决定频谱属于哪种制式使用，这种迁移相当于静态的频谱划分，属于静态FDM的范畴。也是2个20M的带宽，为什么是20M呢？因为LTE最大支持的载波就是20M。跟中兴的方案，总体上差别不大。 图3-3 华为在中移动2.6G上的动态频谱共享解决方案 3.3 动态频谱共享IN FDD在FDD的网络中，爱立信和诺基亚存量的份额比较高，相对华为和中兴，有市场的优势。在存量LTE和新部署NR的融合过程中，如何利用好低频的FDD网络快速部署NR，爱立信和诺基亚更积极一些。这里主要讲一下他们的动态频谱共享方案。图3-4是他们的频谱共享演进示意图。这里将主要介绍在FDD诺基亚和爱立信实现的协议细节，具体的解决方案将在下个章节进行介绍。 图3-4 LTE和NR动态频谱共享的 IN FDD 示意图 FDD上下行频段分开，不存在上下行串扰，很容易利用上行或者下行的载波资源，用来补充NR的业务。例如SUL，利用FDD的上行频段扩展NR的覆盖。在频谱共享的中，如何利用到FDD的上下行资源呢？上行频段基站的行为较少，比较容易控制；下行频段基站的测量信号和信号比较多，在处理时就需要考虑最大化利用LTE或者NR频谱，让LTE和NR高效的融合，例如： SSB，CSIRS，TRS，DMRS，PDCCH等等。接下来将详阐述这些资源在FDD制式中，如何以LTE共享共存。 图3-5 LTE和NR共存是NR SSB的放置示意图 in Non-MBSFN 3.3.1 如何放置SSBNR PDSCH传输的情况下，SSB资源分配与LTE CRS冲突，而且由于帧结构的差异，子载波间隔也可能不同。LTE有MBSFN的子帧，在MBSFN子帧中，除了前两个符号被用于传输控制信号外，其他的符号都可以空出来。那么，在处理NR数据时，就要考虑MBSFN和非BMBSFN。 Non-MBSFN子帧 NR的SSB需要4个连续的符号，不能更改LTE或者NR的SSB结构，唯一的方法就是在找到资源让NR的SSB挤到进去。如图3-5所示SSB在不同case下的可能放置的情况，LTE的CRS使用的RE与天线port数相关，下图示例为1/2/4port场景。LTE的子载波间隔固定在15KHz，对应NR的3种case。 Case 1： NR和LTE都是15kHz，NR连续4个符号的SSB都会与CRS冲突； Case 2：NR 30kHz，占用2符号的LTE是可行的； Case 3：NR 30kHz，在1/2port的LTE是能够放置的，在4port时会与LTE的CRS冲突。当LTE和NR的子载波间隔不同的时候15kHz和30kHz，会破坏正交性，不能按常规的并排放置数据，需要加保护间隔，如图3-6所示。保护带宽虽然能避免喜好的冲突，但是无法兼顾所有的case场景，而且还会让带宽利用率减低。因此在Non-MBSFN的不太适合放SSB信号。PALCE_SSB9.png 图3-6 LTE15kHz和NR 30kHz SSB共存放置的示意图 MBSFN子帧怎么才能兼顾到多场景的case，还不用考虑LTE由于port数配置的差异导致的？MBSFN子帧，恰到好处！MBSFN子帧不能完全为空。需要定义了一个非MBSFN区域，该区域的长度可以是1-2个OFDM符号。该区域旨在承载用于LTE的控制信道，如PHICH，PCFICH和PDCCH等。NR传输只能在MBSFN子帧内从OFDM符号2或3处开始。在MBSFN子帧中不用考虑CRS的影响。图3-7示意在MBSFN中如何放置NR的SSB，在case 1/2/3的时都可以完美的放下至少1个SSB。 图3-7 LTE和NR共存是NR SSB的放置示意图 in MBSFN LTE中有6个帧可以配置为MBSFN子帧，分别是#1,#2, #3, #6, #7, #8. 为了减少MBSFN对LTE的性能影响，通常只配置1个MBSFN子帧，用sib2进行广播。bypass掉MBSFN subframe中LTE符号的情况下，剩余的符号可以传输 NR SSB, SIBs, CSI-RS, TRS and PDSCH data 等。 从对LTE吞吐量的影响来看，基于MBSFN频谱共享，通常不是数据的最佳选择。但是，使用MBSFN子帧对于基于SSB SCS提供SSB传输非常重要，因此是首选的DSS解决方案。 【注意】这里case3 虽然时针对TDD得场景，但是考虑到上下信号得干扰和资源使用率以及客户得需求，TDD下得TDM方式得动态频谱方案暂时没有厂商实现。 3.3.2 如何放PDCCH和PDSCH与放置SSB信号类似，如何放置PDCCH，也需要考虑MBSFN和Non-MBSFN的情况。在Non-MBSFN的子帧中，频谱上直接同时铺LTE和NR数据，如3-8图所示，NR CORESET与LTE控制信道位置冲突。如果将coreset往后挪来给2个符号只放到符号2上，但是仍然会有NR PDSCH与LTE CRS重叠，与LTE中的控制信道类似，无论PDSCH区域的大小如何，CRS对整个频带上的所有设备都是可见的。无法正常工作。 图3-8 NRPDCCH和PDSCH和LTE同 slot共铺数据示意图（1） 如何保证LTE和NR的数据都能在频谱上不冲突的时候的共享编码呢？除了CRS还会有其他的信号干扰到NR的PDSCH嘛？还有SSB。针对SSB和CRS，可以采用，ratematching的方式（图3-10是CRS RateMatching示意图），，将他们所在的RB或者RE打孔掉，不放置NR的PDSCH数据，同时把NR的CORESET / PDCCH配置到位于符号2。这样就能解决PDCCH和PDSCH传输的问题。 图3-9 NRPDCCH和PDSCH和LTE同 slot共铺数据示意图（2） 图3-10 无LTE-SSB的时候crs ratematching，单符号DMRS，无附加导频 图3-11 LTE-SSB和LTE-CRS rate matching的打孔示意图 当PDCCH符号放到了符号2，那么PDSCH的符号必须从符号3开始，由于pdsch dmrs的占用，pdsch在不使用dmrs剩余符号的时候只能从符号4开始，因此无法在pdsch typeA的时候进行频谱共享。需要将pdsch的type类型调整为typeB。图3-12 展示的tapeA和typeB的差异。 图3-12 NR PDSCH typeA和typeB的差异 示意图 3.3.3 如何放置PDSCH DMRSNR pdsch的DMRS导频信号，根据配置的天线数和映射方式有一定的差异，在LTE的 FDD一般都是4port以下，因此这种影响基本可以忽略掉，稍微简单处理，考虑单符号的导频即可，最多3个附加导频信号场景即可。图3-13是NR PDSCH DMRS单符号，3个附加导频的情况；第3个附加导频在LTE为1/2/4port的时候都会与CRS产生冲突。如何规避掉部分呢？跟PDSCH一样打孔掉嘛？可能行不通，因为，LTE的CRS随着小区的PCI在频域的符号是有变化，而且NR的DMRS也会随着天线端口变化，考虑从RE级规避是不现实的。 图3-13 NR PDSCH DMRS放置示意图（1） 将最后一个DMRS的符号位置移动一下，可行嘛？如图3-14，把NR的第三个附加导频符号往后移动一个，可以完美的避开LTE的CRS，不论是1/2/4port的哪种场景都OK。 图3-14 NR PDSCH DMRS放置示意图（2） 3.3.4 上行链路的调整在NR和LTE中均使用15 kHz SCS的时候， NR载波不会与LTE载波完全映射在同一频率网格上。 NR和LTE上行子载波映射之间的差异约为7.5 kHz，如图3-16所示。需要加以缓解，否则会由于 LTE和NR的非正交子载波而引起载波间干扰。为了应对这种情况，在NR需要引入了7.5 kHz频移，这是所有进行动态频谱共享部署的必需功能。此处的偏移通过sib消息通知UE，配置项如图3-15所示。 图3-15 NR上行频偏的配置项 图3-16 NR PDSCH 上行移频示意图 3.3.5 需要的UE能力为了在LTE和NR频谱的共享共存的过程中，让业务保持下去，在不改变LTE网络的前提下，需要NR UE的支持一下几个功能： 支持PDCCH放置在符号2 能进行LTE-SSB的rate-matching 支持TRS放置在符号6和10 支持灵活的CSIRS放置 当配置LTE CRS的时候，支持附加导频符号后移 上行7.5kHz的偏移 当配置LTE CRS的时候，支持LTE CRS的ratematching 支持NR pdsch typeB的映射方式 表4-1 中国区三大运行商的频谱和DSS的需求情况 电信运营商 5G频谱 存量频谱 动态频谱共享的需求 中国移动 N41 2.6G 160M/N79 4.9G 100M 2.6G TD-LTE 2.6G TD网络的主力频段，中移动独享超大带宽160M，DSS需要适配大带宽网络 中国电信 N78 3.5G 100M 2.1G FDD-LTE 3.5G不需要DSS，2.1G需要 中国联通 N78 3.5G 100M 2.1G/1.8G FDD-LTE 3.5G不需要DSS，2.1G需要 4. 如何设计自己的动态频谱共享方案？5G在发展和部署的阶段，逐渐模糊了宏站和小站的区别。在客户来讲，他们似乎并不觉得小站要比宏站差多少，除了规格的和尺寸之外。从各大主设备厂商的主力产品和他们面向的的大众市场来看，他们基于需求和场景的差异，对动态频谱共享各自的侧重点。参考宏站厂商的策略， BaiCells该如何布局动态频谱共享。 4.1 华为和中兴TDD动态频谱共享的需求背景中兴和华为面对的大本营市场是TDD的NR网络，中移动是市场的关键。中移动的2.6G频谱中有存量的LTE网络；由于带宽比较大，让LTE和NR共存的方式进行动态频谱共享，并不适应大带宽的部署；而且，他们的主设备是MIMO 8T8R的TDD以上的设备，不适合进行符号级的共享，因为LTE大多数并没有走进8流以上的MIMO；除此之外，处理多MIMO的符号级共享实现的复杂的更高，带宽利用率也不理想，在上下行共slot的时候会浪费更多。基于这些考虑，针对中移动的载波级共享的，华为和中兴提出了动态频谱共享的Hybrid DSS和 Super DSS，在3.2节中已经介绍。针对电联的FDD的网络，华为和中兴的实现与爱立信和诺基亚并本质的区别，场景更突出，这里就不讨论。 图4-1 TDD 100M 40M在动态频谱共享示意图 4.2 爱立信和诺基亚在FDD动态频谱共享的需求背景在c-band的大带宽频谱范围内，没有考虑频谱共享，因为这些频谱中不存在LTE网络。在欧美，频谱价格比较昂贵，每个运行商拿到的频谱范围都有差异，面对昂贵的频谱和中高频覆盖的劣势，每个运营商拿到频谱有限； 这些优势带宽，在北美被军事用途占据不发提供运营； 只有穿透力更弱的FR2频谱， 面对这样的现实问题，低频段广覆盖的优势，在5G部署的时候显得格外珍贵。在这样的背景下，爱立信和诺基亚分别提出了自己的基于动态频谱共享的方案。 表4-2 欧美主要地区频谱现状 市场区域 5G频谱 主要存量频谱 动态频谱共享的需求 北美 C-band 被军用卫星占用授权FR2的频谱 Low band FDD 高频不需要频谱共享，频谱太贵，低频需要重耕使用 欧洲 C-band和FR2的频谱 Low band FDD 高频不需要频谱共享，频谱太贵，低频需要重耕使用 诺基亚的方案与爱立信的本质上并无太大的差别，在低频段FDD网络部署动态频谱共享，通过低频与中频的CA扩展中频的覆盖。在处理的时间间隔上，诺基亚通过对比不同时间切换网络收益情况，采用了10ms的周期切换间隔。认为10ms在回报比和开销上是最好的。诺基亚还提到了网络切片技术是DSS的发展方向。 图4-2 诺基亚动态频谱共享解决方案 图4-3为爱立信的频谱共享解决方案，通过中频+低频网络的结合，成倍的扩展5G的覆盖；同时也解决了快速部署5G网络的烦恼。在部署中，通过上行行开关控制频谱共享的链路方向，在UE支持同时中频和低频的band时，利用载波聚合，结合中频和低频的频谱，这样就可以让远、中、近的用户都感受到NR网络便利。爱立信实现了1ms的高效快速地动态频谱共享。相应的技术细节在3.3节已经介绍。 图4-3 爱立信的动态频谱共享部署解决方案 查找动态频谱共享在TDD的实现的相关内容，看到了罗德公司关于DSS在TDD的描述[2]。从问答的描述可以看出，实现DSS的关键工具MBSFN主要是为FDD设计的，TDD的网络基本不需要与LTE共享（除了中移动160M的频谱），因为5G的TDD网络在欧美，不是没事用就是对LTE不可用，因此对DSS的需求也几乎没有。 图4-4 关于DSS的部分问答 针对不同客户的不同场景，你的解决方案是什么呢？ 参考资料[1]. 33060-dynamic-spectrum-sharing-is-a-game-changer[2]. DSS_QA.pdf[3]. 33239-nr-and-lte-coexistence-through-dynamic-spectrum-sharing[4]. 5G_DSS.html#Ref_05[5]. Dynamic-Spectrum-Sharing-WhitePaper-PDFDSSWP-031320.pdf[6]. (A4) 5G NR Dynamic Spectrum Sharing Drivers &amp; Test Implications_Alex Liang.pdf[7]. implementing-dynamic-spectrum-sharing[8]. article-dss-enabling-5g-nr-in-standard-lte-subframes-part-1-_254008.html#media-gallery-7[9]. sarticle-dss-5g-nr-lte-coexistence-through-dynamic-spectrum-sharing-part-1-_254002.html#media-gallery-8[10]. implementing-dynamic-spectrum-sharing[11]. nr-lte-coexistence-dynamic-spectrum-sharing-dss[12]. RWS-180011.pdf[12]. dynamic-spectrum-sharing-for-5g-nr-and-4g-lte-coexistence[13]. new-3gpp-effort-on-nr-in-unlicensed-spectrum-expands-5g-to-new-areas.pdf[14]. 2020-08-26_ITU_Spectrum-Planning-for-Emerging-Technologies_Ericsson.pdf[15]. 1805.05591.pdf[16]. public_policy_position_5g_spectrum.pdf[17]. dss-the-5g-deployment-x-facto[18]. 10109-Industry-s-First-Tri-RAT-Dynamic-Spectrum-Sharing-Solution-for-Realizing-Fast-5G-Deployments[19]. 33867-zte-and-china-unicom-implement-industrys-first-tri-rat-dynamic-spectrum-sharing-solution[20]. dynamic-spectrum-sharing-standardization[21]. first-cloudair-lte-tdd-nr-dynamic-spectrum-sharing-commercial-verified-by-china-mobile-and-huawei]]></content>
  </entry>
  <entry>
    <title><![CDATA[5G常见问题定位]]></title>
    <url>%2F2021%2F04%2F29%2F5G%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[1. SR达到最大重传次数 check UE的盲检位置能否对上 BWP的位置是否正确，若基站已经切换了BWP，而UE还在BWP上解调就解不出DCI 聚集级别是否正确 1CCE = 6REG 2. DCI漏检问题 检查PDCCH是否存在问题-SSR波束和RACH波束是否使用正确，SSB用cell的静态波束，RAR用RACH的测量波束；普通的数传报文，有SRS波束用SRS波束，没有SRS听RACH波束； check DCI类型数值value是否正确 L2下发的L1报文是否被L1校验 查看是否有大量的DTX，看UE接收到的DCI个数是否满足是满的 3. 影响峰值速率的因素 pdcch_grant不足，以100M，30kHz，上下行时隙配比8:2，pdcch dl/ul grant 分别是1600次和400次； RB调度不足，100M在每个时刻都有对应的RB数，平均下来峰值场景大概265个RB； pdcch_grant不足和RB调度不足可以归纳为调度不足，主要看（1）是否有来水不足；（2）是否有AMBR限；核心网开户信息中包含了两个重要息：AMBR，QCI。AMBR限制了UE的Non-GBR速率；用户QCI信息会与基站侧的QCI级的PDCP、RLC相关定时器参数（包含SN bit数、RLC模式等）进行关联，从而影响到用户的吞吐率性能；UE AMBR/QCI信息可以通过S1口跟踪S1AP_INITIAL CONTEXT SETUP REQ或者X2口SgNBAdd Req查看。(3)是否有DCI漏检，查看CSI-RSRP，是否是覆盖差导致DCI漏检；检查配置查看PDCCH聚合级别，聚合级别太低会造成DCI漏检，推荐自适应；DCI资源不足，调度用户数太多也会导致DCI漏检；(4)传输问题，如果是TCP业务，先通过UDP灌包排查是是空口问题还是TCP问题；针对上述问题总结下来主要可以归纳为以下三类： 协议栈 影响因素 PDCP 入口流量不足，缓存满丢包，超时丢包，PDCP SN长度不够 RLC RLC入口流量不足，RLC重传，RLC窗口满停止调度 MAC harq资源耗尽，DCI漏检 mcs低，MCS反应的是信道质量SINR映射到CQI关系，(1)当CQI比较低，MCS会比较低，要跑满调度，就需要提升CQI；(2)当基站接收功率过高，引起接收器件的削波，导致SINR降低从而导致MCS下降，会使速率下降; 一般情况下，CSI-RS SINR&gt;25dB，CSI-RSRP在（-65dbm~-80dbm），不宜超过-65dBm；(3)时频偏问题；(4)干扰问题，主要分为邻区干扰、越区干扰和外部干扰。邻区干扰一般由于邻区过覆盖对当前小区产生干扰；越区干扰，需要看是否有较远距离的小区越至服务小区的范围；外部干扰，需要进行扫描人工分析；当出现高RSRP低SINR（如：RSRP均值&gt;=-80dBm，SINR均值&lt;=15dB）且MCS等指标都偏低，那么就有必要进行干扰问题排查； mcs/rank 被固定，导致UE无法调度更高的mcs和rank； cqi上报异常，CQI上报分为CSI-RS异常和SRS异常，(1)CSIRS异常，CSIRS基站侧配置端口数与测试终端数不一致时会导致CSI/CQI测量异常，导致UE无法上报CQI，此时会导致mcs&amp;rank低；(2)SRS异常，Massive MIMO主要通过SRS信号来做上下行互异性，基站收到终端上报的SRS或，才会下发CSI测量，UE才会上报CSI测量(CQI/PMI/RI), 然后网络侧基于UE上报的CQI进行链路自适应；因此SRS异常会使CQI异常。 rank低，rank用来指示PDSCH的有效的数据层数，Rank最大值min(gNB天线,UE天线数)，一般基站的天线远大于UE的天线数，因此rank主要取决于UE端的天线数。(1)测试环境【优先选择站下近点，CSI-RS SINR&gt;25dB，CSI-RSRP在（-65dbm~-80dbm），不宜超过-65dBm】；(2)小区间频繁切换,切换后用户初始接入，低RANK、低MCS能保证接入和切换成功率，切换后初始的RANK值默认为1，大概在30ms左右可调整回来，影响较小；但是如果发生频繁切换，会导致RANK无法快速爬升。(3)MCS表频繁切换, MCS表格切换指的是在一定条件下进行64QAM和256QAM的MCS表格切换。在切换期间RANK固定为1进行调度; (4)终端能力,协议规定单用户下行最多可支持8流；上行最多可支持4流。 通道校正异常，通道校正失败后，系统由于无法准确评估SRS权值，所以会默认使用DFT开环权进行业务，gNB会根据UE上报的RI来选择rank，遵从如下规则：1）UE CSI的RI为1，则当前使用RANK为1；2）UE CSI的RI为2-3，当前使用RANK为2；3）UE CSI的RI为4-8，则当时使用RANK为4。 下行SRS权与PMI权自适应，下行SRS权与PMI权自适应，允许用户在SRS SINR较大时，选择基于SRS得到的BF权值；在SRS SINR较小时，选择基于PMl的BF权值，相对于SRS权，远点用户的PMI权可以提升权值准确性，提升边缘用户的SNR，进而提升边缘用户的速率；1）当用户上行SRS SNR大于ThsRs（默认-2dB）该用户选择SRS权；2）当用户上行SRS SNR小于ThpMl（默认-8dB）该用户选择PMI权；3）当用户的SRS SNR在ThsRs和ThpM之间时，该用户权保持不变；当使用SRS权值时，基站使用Rank自适应算法确定最终使用Rank值；使用PMI权时，Rank自适应算法不生效，直接使用UE上报的RI当PMI未上报，或刚刚切换，或通道校正未通过时，则使用DFT权，根据UE上报的RI来选择Rank，但遵从如下规则1)UE CSI的RI为1，则当前使用RANK为1;2)UECSI的RI为2-3，当前使用RANK为2;3)UECSI的RI为4-8，则当时使用RANK为4; 4. 切换后流量不足掉坑 检查切换前后流量是否已经降低； 切换的时延是否异常，如时延过大； 切换后来水不足导致调度不足； 切换后MCS异常，rank异常； 切换前后是否存在多径，频偏过大； 其他，比如干扰等； 5. rank和mcs不符合预期 rank不符合预期：（1）确认UE的天线数，L3配置的CSIRS port数是否大于等于UE上报的RI；（2）rank自适应是否正常； 误码较低的时候mcs差：（1）当前是否处于弱覆盖；（2）下行频段较大；（3）权值自适应异常；（4）上行TA异常；其他参考影响峰值的内容。 参考文献：[1]. xxx厂问题定位指导书]]></content>
  </entry>
  <entry>
    <title><![CDATA[5G基础-NR接入过程]]></title>
    <url>%2F2021%2F04%2F29%2F5G%E5%9F%BA%E7%A1%80-NR%E6%8E%A5%E5%85%A5%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UE的接入无线承载网的过程，分为初始接入和随机接入两个过程；以下是NR SA的场景下的通过空口在UE和NW（网络）之间信令流程： 1. 初始接入UE通过基站广播的PSS/SSS信息对齐频率、时间以及获得接入所需要的参数： 基站广播PSS/SSS/PBCH Block（SSB）：一个SSB有4个OFDM符号由PSS/SSS/PBCH组成，频域上有240个子载波（0-239编号）20个RB（一个RB12个子载波），协议38.211 7.4.2章节描述定义； UE检测到一个SS/PBCH Block,定位到PSS和SSS之后，UE便可以在时频域知道MIB消息的位置，应为MIB消息的位置是相对PSS和SSS固定的，MIB消息的内容有子载波间隔、PBCH的DMRS符号位置、SIB1所在的时频位置（由L3的PDCCH-Config SIB1配置）和频带大小、是否禁止用户驻留、是否容许用户直选到同频邻区等；解到MIB之后就可以解码PBCH的内容，获取SS/PBCH index、定时等信息；SSB Block Pattern有五种case A-E（1）SUB3G（A-C）其中FDD频段最大4个SSB Block，每个对应一个SSB Index；（2）sub3G-sub6G A-C定义8个SSB；（3）Above 6G （D-E）定义64个SSB； 38.321 6.1.4 MIB/SIB/OSI消息格式 SIB1消息提供了UE准许接入和OSI调度的信息，以及初始BWP相关的频域位置和带宽，寻呼，PRACH接入等关键信息；SI-SchedingInfo 中SIB1字段中的valueTag字段在SI消息发生变化时都是加1，用于指示SI消息是否发生变化，UE使用这个字段检测自己之前保存的SI消息是否发生了变化； UE根据mib中中内容获取RSMI所在的频域位置（初始BWP的位置，PDCCH common coreset的视频位置），然后获取RMSI，并从RMSI中获取RACH的位置信息，上下行初始BWP的信息、PUCCH的配置等信息。 BWP0阶段 PDCCH信道频域RB的位置与PDSCH信道是一致的 UE在对应的RACH occasion上发送RACH Preamble。 2. 随机接入 随机选择preamble Id发送preamble：UE从SS_RSRP大于RSRP_ThreadSSB选一个SSB-RSRP最好的SSB波束。如果没有最好的额，就随机选一个SSB波束，在从SSB的preambles中随机选择一个preamble Id发送preamble，告诉基站有一个随机接入请求，并使基站估计与UE之间的传输时延，以便基站校准uplink timing并通过RAR的timing advance command告知UE；基站通过sib1广播告知UE，基站的RACH信道的视频位置、preamble序列格式、序列产生的参数等信息，用来解答UE在什么时候（prach-configuration-Index）以在什么位置（prach-frequencyOffset）以什么格式（prach-configuration-index）多大的功率（min(Pmax, PREAMBLE_RECEIVED_TAR_GET_POWER+Rl)）发送RA。 preamble的作用：告诉基站有一个随机接入请求，并使基站估计其余UE之间的传输时延，以便在RAR中下发TAC； 基站下发RAR：基站对不同的preamble分配不同（的TC-RNTI和UL-Grant资源等，并通过preamble测量到初始的TA值，在RAR中发送给UE；UE在发送Preamble之后，会在RAR的响应时间窗内，监听PDCCH以接收对应RA-RNTI的RAR；基站侧用RA-RNTI加扰的PDCCH的公共搜索空间中的的DCI1-0告诉UE。如果UE在时间窗时间内发生：(1)在时间窗内用RA-RNTI没有盲检到DCI；(2)没有盲检到PDCCH CRC错误；(3)RAR中的RA-PID与preambleId不一致；就认为本次RA接入失败；UE RA失败后重发preamble与RAR PDU中的BI(backoff Indicator)字段相关，如果RAR PDU中的携带了BI，那么UE会在0-BI中随机选取一个时刻重新发preamble接入；BI的大小反映了小区的负载； RAR的响应时间窗（RA Response Window）在rach-configGeneric中配置，配置项为ra-ResponseWindows单位是slot； UE发msg3 RRC_SETUP_REQ RRC承载建立请求：UE收到RAR之后，通过解析，RAR的payload获取msg3发送时刻的视频资源，采用的mcs和功率等信息，UE在这个过程中会发送一个39bit的随机值（申请RRC Setup请求）；首次发送msg3时以RV版本号0发送（默认顺序0-2-3-1），若基站收到msg3 CRC错，则会基站通过以TC-RNTI加扰的DCI format0-0将信息告知UE；==UE发送完成后msg3后会启动Ra-COntentResolution定时器（这个定时器在sib1中的RACH-Config-Common中配置），在这个定时器期间UE会等待基站是否让自己接入，也就是冲突解决的过程； 基站发发msg4 RRC_CONN_SETUP，并进行冲突解决: 在CCCH上发送，携带SIB1资源的配置的详细信息，同时如果有竞争接入会有竞争解决的过程，（冲突解决）基站把msg3的钱48bit作为UE Contention Resolution Identity MAC CE发送，其中包括了mcs的39bit随机值；msg4通过preamble Id和Tc-RNTI发送，终端收到ms4之后，会把竞争解决的MAC CE解析出来，和自己的msg3的前48bit对比，如果相等则认为自己竞争成功，否则竞争失败，在sib1的定时器之后再重新发起接入； UE时RRC非连接态：通过网络侧提供的S-IMSI作为标识，如果没有提，使用一个39bit的随机值作为临时标识，并通过CCCH告诉基站，基站在msg4时通过UE冲突是否解决；UE时RRC连接态：msg3中UE通过C-RNTI MAC CE将自己的C-RNTI告诉基站，msg4中基站用这个C_RNTI来解决冲突。 UE发msg5 RRC_CONN_SETUP_COMPLETE，完成RRC链接建立：通过DDCH的SRB1承载发送，携带上行方向的NAS消息，基站收到RRC_CONN_SETUP_COMPLETE消息之后，RRC链接建立完成，SRB2承载就会随之建立。 初始上下文建立： 建立UE与AMF的之间的绘画，让UE与AMF之间保持交流，由AMF发起，初始上下文建立完成就表示UE与AMF之间完成连接； UE能力查询：UE能力主要有UE的天线能力（也就是支持的频段等信息）和UE的网络能力（加密算法，NAS等的支持情况）；基站根据核心网在UE上下文建立的请求中是否携带了UE能力，来决定是否进行查询，如果UE携带了则不下发UE能力查询。下图是NR SA UE注册的流程示例，从msg3一直到注册完成； 参考文献：[1]. 5G Standalone Access Registration Signaling Messages[2]. 5G Standalone Access: Registration Procedure[3]. 5G/NR-初始Aattach 3. 随机接入触发的场景随机接入并不是只有新入网才会触发，还会发生在一些已经入网的UE身上，梳理出来主要有一下8大场景； 初始RRC连接建立：当UE需要和基站建立连接时，UE会发起随机接入； RRC重建：当UE需要和基站重新建立RRC连接时； UE进行切换时：UE会在目标小区发起随机接入； 下行数据到达：UE处于RRC连接，有UE有下行数据要发送，但发现UE失步，此时基站会通过下行控制信令让UE发起随机接入；若UE处在DRX休眠，则需要等UE变为Active后再下发控制信令； 上行数据达到：UE处于RRC连接，有UE有上行数据要发送，但发现UE失步，UE会发起随机接入； NSA接入，LTE小区接入，添加NR小区时，会发起随机接入； 基于RA请求SI：当UE需要请求特定的SI时，会发起随机接入； 当UE处在RRC-INACTIVE：（1）主动迁移到RRC-CONNECTED时，UE会发起随机接入；（2）基站需要UE迁移到RRC-CONNECTED是，基站会通过paging让UE发起随机接入； 其中：1、2、5是竞争接入；3、4是优先非竞争接入，如果没有转悠preamble触发就是竞争的随机接入；6、7是非竞争接入；8如果是UE发起的就是竞争接入，如果是网络侧发起的就是非竞争接入。 4. RRC重建与重同步4.1 RRC重建RRC重建是快速建立RRC连接的一种业务，重建的前提是UE已经与基站建立RRC连接，且已经成功启用安全模式，才能发起RRC重建；若是安全模式激活前发起重建，会发生重建失败，UE直接进入IDLE态，主要在以下几个场景中会触发RRC重建： 检测到无线链路链接失败（38.331 5.3.10），主要有T310超时、RA失败且T311未运行和RLC达到最大重传； NR-RRN系统内，异系统切换失败； L3收到底层完整性校验失败的报告； RRC连接重配失败； 4.2 重同步重同步的过程是UE重新接入的过程，是在UE或者基站有上行或者下行数据要发送时发现UE与基站失步了，由UE主动发起或者基站被动发起的同步动作； 对于SA基站收到msg4的ACK就认为上行同步； 对于NSA基站收到UE发送的首个数据报文（msg5）就认为上行同步； 重同步的触发： UE有上行数据要发，UE发现上行失步，有UE发起竞争重同步； 基站有下行数据要发，发现上行失步，有基站触发UE发起竞争重同步； SUL场景上下行数据到来，会触发重同步； 在基站和UE维护和管理同步状态是由一个同步定时器， 当UE收到基站的TA MAC CE时，会重启定时器； 基站收到UE的TA MAC CE时，也会重启定时器； 参考文献：[1]. xxx大厂问题定位指导书]]></content>
  </entry>
  <entry>
    <title><![CDATA[5G基础-时隙和帧结构]]></title>
    <url>%2F2021%2F04%2F28%2F5G%E5%9F%BA%E7%A1%80-%E6%97%B6%E9%9A%99%E5%92%8C%E5%B8%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. 时隙结构LTE的子载波间隔是固定的15kHz，在NR中针对不同频谱的应用场景设计了5种不同的子载波间隔，图下表： 无论是哪种子载波间隔，每个RB包含的子载波个数仍然是12个。在NR中，对于normal CP类型，每个slot包含的符号数是14，每个帧包含的slot数根据子载波间隔的不同也有差异。 在NR里，每个frame帧仍然包括10个subframe子帧，每个子帧的长度固定是1ms。子载波间隔越大（即频域越宽），相应的slot时间越短（即时域越窄），相应的每个symb符号长度也越短。上表列出了NR支持的5中不同的帧结构，对应不同的μ，有着不同的帧结构。 2. slot Format时隙格式slot format，是用来表示一个时隙里的每个OFDM符号的传输方向是什么；在NR中，一个时隙里的OFDM符号，被分类为三种：DL符号、flexible符号和UL符号。在TDD的系统就对应成DL slot、S slot 和UL slot；下行数据可以在DL符合和flexible符号中传输，上行数据可以在UL和flexible中传输。在38.213-f60协议中，定义了56中时隙格式，如下表所示： 为了能够调度的更加灵活，定义这么多的时隙格式，当前下行的数据负载很大，可以配置Slot Format 28#；当前上行的数据负载很大可以配置SlotFormat 34#。有这么多slot format，系统是怎么下发这个Slot Format配置？UE收到Slot Format配置之后，是怎么处理的呢？ 3. UE如何获取基站的slot format上表的第一列是Slot Format Indicator，指示当前基站采用的时隙格式，该参数由基站侧配置并下发到UE。UE可以通过解析系统信息来获取小区的时隙格式Slot Format，也可以通过解析特定的DCI来更新时隙格式。 系统消息获取slot format ? SIB1中ServingCellConfigCommonSIB信元用于配置UE所在服务小区的小区特定参数，ServingCellConfigCommonSIB信元里有名为TDD-UL-DL-ConfigCommon的信元，该信元用于确定小区特定的上下行TDD配置；时隙格式相关的参数就可以通过解析TDD-UL-DL-ConfigCommon信元中的TDD-UL-DL-Pattern信元得到。UE获取到这些参数后，就可以得到当前基站的上下行时隙格式。TDD-UL-DL-Pattern dl-UL-TransmissionPeriodicity：表示DL-UL模式的周期，用变量P表示，单位是ms，它的取值范围是ms0p5, ms0p625, ms1, ms1p25, ms2,ms2p5, ms5, ms10，分别对应0.5ms、0.625ms、1ms、1.25ms、2ms、2.5ms、5ms、10ms。 如果我们用变量u_ref来表示referenceSubcarrierSpacing这个值，那么：(1)只有当u_ref=3的时候，P才能取0.625ms，此时如下表所示，子载波间隔为120kHz。(2)只有当u_ref=2或3的时候，P才能取1.25ms，此时子载波间隔为60 kHz或120kHz。(3)只有当u_ref=1或2或3的时候，P才能取2.5ms，此时子载波间隔为30kHz或60 kHz或120kHz。 nrofDownlinkSlots：表示从每一个DL-UL模式的开始位置起，全部连续的下行时隙的个数，用变量d_slots表示。最小值是0，目前的R15版本协议规定最大值可以取80 nrofDownlinkSymbols：表示从最近的一个全连续下行时隙开始，连续的下行符号个数，用变量d_sym表示。最小值是0，最大值可以取13。 nrofUplinkSlots：表示在每一个DL-UL模式的结尾处，连续全上行时隙的个数，用变量u_slots表示。最小值是0，目前的R15版本协议规定最大值可以取80。 nrofUplinkSymbols：表示在第一个全上行时隙之前的最后一个时隙中，连续全上行符号的个数，用变量u_sym表示。dl-UL-TransmissionPeriodicity参数可以取8个周期值，这8个周期值，有一定的规则约束需要遵守， 从DCI里获取slot format ? R15版本的38.213中表7.3.1-1中定义了8中DCI formats，其中DCI2_0指示UE组的slot format。DCI 2_0用SFI_RNTI (Slot Format Indicator- Radio Network Temporary Identifier)来加扰，SFI_RNTI在RRC的PDCCH-ServingCellConfig信元中的SlotFormatIndicator信元中得到.PDCCH-ServingCellConfig information element ==SlotFormatIndicator information element== 在DCI 2_0码流中携带的是N个slot format indicator的比特流，格式为： DCI 2_0的码流大小由上边的dci-PayloadSize配置决定，最多可以携带128bits。DCI 2_0码流中的Slot Format Indicator为SFI-Index，只是一个ID索引号，范围是0~511；SFI-Index都对应一个SlotFormatCombinationsPerCell信元，这个信元被封装在SlotFormatIndicator信元中。 SlotFormatCombinationsPerCell information element SlotFormatCombinationsPerCell information element中的slotFormats参数才是真正的时隙格式参数，对应这个slot flormat的表中的第一列indicator 0-255；slotFormatCombinationId是DCI2_0码流中SFI_Index， DCI 2_0能够动态的修改时隙格式参数并通知到UE，为了进一步提升系统的传输性能，DCI 2_0里尽量只考虑携带有限个比特的SFI_Index索引，UE在提取到N个SFI_Index之后，再通过匹配SlotFormatCombinationsPerCell信元中的slotFormatCombinationId字段，获取到SlotFormatCombinationsPerCell信元中的更多参数。 参考文献 3GPP TS 38.211: “NR; Physical channels and modulation (Release 15)” 3GPP TS 38.212: “NR; Multiplexing and channel coding(Release 15)” 3GPP TS 38.213：“NR; Physical layer procedures for control (Release 15)” 3GPP TS 38.331:”NR; Radio Resource Control (RRC) protocol specification (Release 15)” http://www.sharetechnote.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++函数对象与lambda表达式]]></title>
    <url>%2F2020%2F06%2F13%2FC-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数对象，一个类如果将()运算符重载，那么这个类就称为函数对象类，使用形式看起来像函数调用，实际执行了函数调用，因此坐函数对象。lambda表达式也称匿名函数，是无需定义标识符（函数名）的函数，如果函数只使用一次或者有限的次数，使用lambda表达式会比较方便。 1. 函数对象的如何实现?C++中将对象当做函数使用，是函数式编程的思想。这里不作深入讨论，只讨论如何使用；举个简单例子：【1】无入参的函数对象：12345678class ObjType&#123;public: void operator() () // 无参数类型的()重载 &#123; cout&lt;&lt;&quot;Hello C++!&quot;&lt;&lt;endl; &#125;&#125;; 【2】有参数的函数对象：12345678class ClcAverage&#123;public: double operator()(int a1, int a2, int a3) // 三个入参 &#123; return (double)(a1 + a2 + a3) / 3; &#125;&#125;; 【3】函数对像的使用STL有个accumulate函数，在定义函数模板的时候，使用的是一个函数对象；它的功能是对 [first, last) 中的每个迭代器 对象 执行 val = opt(val, *I)，返回最终的 val。Dev C++，定义这样的：12345678template &lt;class InIt, class T, class Pred&gt;T accumulate(InIt first, InIt last, T val, Pred opt)&#123; for (; first != last; ++first) &#123; init = opt(init, *first); &#125; return init;&#125; 模板被实例化之后，opt(init, *first)需要定义，opt只能是函数指针或者函数对象。在使用时，实参只能传递函数名，函数指针或者函数对象。这里以函数对象为例举例说明： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;numeric&gt;template&lt;class T&gt;class SumPow&#123;public: SumPow(int pow) :m_pow(pow) &#123; &#125; const T operator() (const T&amp; total, const T&amp; value) &#123; //计算 value的pow次方和 T v = value; for (int i = 0; i &lt; m_pow - 1; ++i) &#123; v = v * value; &#125; return total + v; &#125;private: int m_pow;&#125;;int SumSquare(int total, int value)&#123; return total + value * value;&#125;int main()&#123; int a1[] = &#123; 1, 2, 3 &#125;; vector&lt;int&gt; a2 = &#123; 1, 2, 3 &#125;; // 实例化为函数指针 cout &lt;&lt; &quot;SumSquares: &quot; &lt;&lt; accumulate(a2.begin(), a2.end(), 0, SumSquare) &lt;&lt; endl; cout &lt;&lt; &quot;SumSquares &quot; &lt;&lt; accumulate(begin(a1), end(a1), 0, SumSquare) &lt;&lt; endl; // 实例化为函数对象 cout &lt;&lt; &quot;SumPow: &quot; &lt;&lt; accumulate(a2.begin(), a2.end(), 0, SumPow&lt;int&gt;(2)) &lt;&lt; endl; cout &lt;&lt; &quot;SumPow: &quot; &lt;&lt; accumulate(begin(a1), end(a1), 0, SumPow&lt;int&gt;(2)) &lt;&lt; endl; return 0;&#125; 示例中，参数是SumSquare编译器实例化成函数的类似于如下的定义：形参opt是函数指针，而opt(init, *first)就调用了指针opt指向的函数SumSquare。123456int accumulate(vector &lt;int&gt;::iterator first, vector &lt;int&gt;::iterator last, int init, int(*op)(int, int))&#123; for (; first != last; ++first) init = op(init, *first); return init;&#125; 参数SumPow&lt;int&gt;(2)编译器实例化成了函数对象，有等效于如下定义的形式，形参是函数对象，相当于调用opt.operator()(init, *first);,也就是SumPow类的operator函数；123456int accumulate(vector&lt;int&gt;::iterator first, vector&lt;int&gt;::iterator last, int init, SumPowers&lt;int&gt; op)&#123; for (; first != last; ++first) init = op(init, *first); return init;&#125; 2.lambda表达式在使用STL的时候，往往需要用很多函数对象或者函数指针。这些对象或者函数指针大部分是一次性，编写在需要的时候编写这样的代码有点浪费。对于只使用一次的函数对象或者函数，lambda表达式是一个有效的解决办法。Lambda表达式也是的闭包的同义词，但是两者也是有区别的，闭包是任何能够访问不在局部和参数列表里定义里面的自由变量的函数实例。C++中的lambda在C++11中才支持。Lambda 表达式的定义形式如下： 1[外部变量访问方式说明符](参数表)-&gt;返回值类型&#123;语句块&#125; 外部变量访问方式说明符是=或&amp;，表示{}中用到的按值捕获还是按引用捕获, 按值捕获表示定义在{}外面的变量，在{}中不允许被改变，按引用捕获表示允许修改。当然，在{}中也可以不使用定义在外面的变量。-&gt;返回值类型可以省略。如下是一个lambda表达式：如果上边不够直观的话，看下边这个图，就更一幕了然。其中，1是捕获说明符；2是捕获参数列表；3是可选的mutable声明；4是可选的异常声明；5是返回类型；6是lambda操作域； 捕获列表 capture clause 捕获 作用 捕获 作用 [] 不捕获任何变量 [] 不捕获任何变量 [&amp;] 引用捕获所有变量 [=] 以值捕获所有变量 [&amp;x] 引用只捕获x [x] 以值只捕获x [&amp;, x] 引用捕获所有变量，x是例外 [=, &amp;x] 值捕获所有变量，其中x是例外 [this] 以引用捕获当前对象 [*this] 以传值方式捕获当前对象 捕获列表 capture clause举个例子，如果lambda主体total通过引用捕获变量，factor通过值捕获变量，则以下捕获子句是等效的：123456[&amp;total, factor][factor, &amp;total][&amp;, factor][factor, &amp;][=, &amp;total][&amp;total, =] 如果捕获子句默认&amp; 按引用捕获，那么identifier在capture捕捉列表中不能再有以引用捕获的形式也就是&amp; identifier。同样，如果capture默认按值捕获capture-default =，则capture该捕获列表不能有按值捕获的形式= identifier。而且，标识符不能在捕获列表中出现多次。需要注意的是默认在捕获列表没有明确捕获方式的时候[]，根据捕获参数列表传参形式决定是值捕获还是引用捕获, 形如[](int &amp;x){x=x*2;}。123456789struct S &#123; void f(int i);&#125;;void S::f(int i) &#123; [&amp;, i]&#123;&#125;; // OK [&amp;, &amp;i]&#123;&#125;; // ERROR: 按引用捕获，在声明i按引用捕获多余 [=, this]&#123;&#125;; // ERROR: this when = is the default [=, *this]&#123; &#125;; // OK: captures this by value. [i, i]&#123;&#125;; // ERROR: 重复声明捕获 [=]&#123;++i;&#125;; // ERROR: 值捕获，不能修改对象&#125; 说了这么多，lambda具体怎么用呢？看一看，下边的例子：12345678910111213141516171819int main()&#123; int a[4] = &#123; 11, 1, 37, 9 &#125;; /* 按值捕获 捕获值不可修改*/ sort(a, a + 4, [=](int x, int y) -&gt; bool &#123;return x &lt; y; &#125;); /* 升序排序 */ for_each(a, a + 4, [=](int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;); /* 依次遍历输出 */ /* 按引用捕获 捕获值不可修改*/ for_each(a, a + 4, [&amp;](int&amp; x) &#123; x *= 2; &#125;); /* 元素平方 */ int x = 1, y=2, z=3; auto lambdaFun = [=,&amp;y,&amp;z](int n) &#123; cout &lt;&lt;x &lt;&lt; endl; y++; z++; return n*n; &#125;; cout &lt;&lt; lambdaFun(15) &lt;&lt; endl; cout &lt;&lt; y &lt;&lt; &quot;,&quot; &lt;&lt; z &lt;&lt; endl;&#125; 最后，说一下lambda的使用的注意事项：1. 引用捕获可修改外部变量，但值捕获不能。（可变允许修改副本，但不允许修改原件）;2. 引用捕获反映了外部变量的更新，但值捕获却没有;3. 引用捕获引入了生命周期依赖，但是值捕获没有生命周期依赖性。当lambda异步运行时，这尤其重要。如果通过异步lambda中的引用捕获本地，则该本地很可能会在lambda运行时消失，从而在运行时导致访问冲突。 参考文献：[1]. https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华硕主板配置NVIDIA显卡windwos10下采坑实录]]></title>
    <url>%2F2020%2F06%2F06%2F%E5%8D%8E%E7%A1%95%E4%B8%BB%E6%9D%BF%E9%85%8D%E7%BD%AENVIDIA%E6%98%BE%E5%8D%A1windwos10%E4%B8%8B%E9%87%87%E5%9D%91%E5%AE%9E%E5%BD%95%2F</url>
    <content type="text"><![CDATA[崇拜信仰，笔者买了一个公版2060Super，刚挂起来，很久没用过独显了。以为直接可用；然而遇到了一些坑，前前后后，大概花了一周才搞定，期间还拿到店铺老板那，检测了一把；虽然问题很简单，这里需要记录一下，希望对后来的同学有用；笔者的配置情况如下表： 软&amp;硬件信息 型号 软&amp;硬件信息 型号 处理器 英特尔 i5-8400 主板 Nvidia RTX 2060 SUPER 主板 华硕PRIME Z370-P 电源 爱国者GT-550 550W 内存 4*DDR4 2400MHz 系统 WIN10 2004 1.下载驱动NVIDIA官方下载对应硬件的最新驱动，下载完成之后，安装即可； 2.安装OK，显卡无法驱动安装完成之后检查，是否可用，用管理员权限进去CMD，输入NVIDIA-SMI看能否查询到显卡信息。笔者这里没查到显示：Failed to initialize NVML: Unknown Erroe; 这时候直接懵逼了，驱动安装成功了，咋会这样了？ 按图索骥，问度娘，貌似很多网友遇到类似的问题，简单归纳一下，主要有一下几类： 系统版本不不兼容，要使用1803以后的版本，这个时候主要表现的问题现象是，驱动与系统不兼容；升级系统版本解决或更换系统至企业版。 驱动版本不对，不应该下载DCH版本，应该在标准版的；解决办法是下载标准版的驱动。 驱动不兼容导致，需要卸载完系统自带的驱动，确保系统自带驱动失效且完全清楚，然后重新安装驱动。删除驱动，提供了DDU v18.0.2.5.exe来清楚系统自带驱动； 结合笔者的实际情况，挨个来看一下这3个问题，首先是系统不兼容，由于笔者系统本身是1803的win10，本着半信半疑的思想，将系统更新到了win10 2004版本；重新下载完所有NVIDIA驱动之后，重新安装，依旧是一样的现象；这个可以排除第一点和第三点；针对第二点的驱动版本不对，当前NVIDIA官方提供的已经没有所谓的标准驱动了，都是DCH的驱动，查询资料和相关介绍确认，win10 在1904版本之后，默认都是DCH且NVIDIA新卡只有当前都是DCH驱动。故排除第二点。 3.问题解决问题没解决，还要继续看，本着问题不解决誓不罢休的精神，笔者继续排查采坑；为了比对系统的差异，特性下载了ubuntu18.4和ubuntu20.4两个系统，安装驱动尝试能否启动；遗憾的是，不论哪个系统，安装完成之后，系统重启就挂掉了，在等待某个配置校验一样，具体原因没有深究。对比ubuntu和windows，发现不论哪个系统安装都会有问题，这里可以认为，不是系统的问题。可能是硬件的原因。继续排查、检索相关问题，偶然看到某个哥们在网上说，要设置启动模式关闭安全模式，然后接上显卡的电源线即可。根据这个提示，进入了华硕主板的bios，在启动中找到了CMS，选择关闭。F10保存记录，重启。重启又看到提示显卡的电源没接please power down and connect the PCIe power cable(s) for this graphics card;拆开机箱，找到显卡的电源接口，街上电源和8pin的电源，然后上电重启，问题解决。CMD输入NVIDIA-SMI查看一下显卡的信息。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C与C++常用函数使用与表达式解析]]></title>
    <url>%2F2020%2F05%2F24%2FC%E4%B8%8EC-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. malloc和realloc这两个函数都是申请内存的函数，他们有什么区别和联系呢？那些场景会出现意想不到的结果呢？下面具体探讨这两个函数. 1.1 malloc函数void *mallco(size_t size); malloc 向系统申请分配指定size个字节的内存空间。返回类型是 void* 类型。 malloc 1、malloc 函数返回的是 void * 类型，定义的哪种类型的指针，必须强转为此类型指针; 2、函数的实参为 sizeof(int) ，用于指明一个整型数据需要的大小； 3、malloc是必须指定内存大小的空间，比如想分配50个int类型的空间：int* p = (int*) malloc ( sizeof(int) * 50 )； 4、是malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的； 闲话长谈malloc(0)与malloc(-1)返回值是什么样的？ 123456789#include&lt;iostream&gt;using namespace std;int main()&#123; int *ptr1=(int*)malloc(sizeof(int)*(0)); int *ptr1=(int*)malloc(sizeof(int)*(-1));; cout&lt;&lt;(ch==NULL)&lt;&lt;&apos; &apos;&lt;&lt;(c==NULL)&lt;&lt;endl;&#125;输出：0 1 先说malloc(-1), 根据定义malloc入参是一个size_t的无符号数，传入有符号的-1，会翻转成无符号数，如果对于int类型就是INT_MAX-1大小的正数；显然这么大的一块内存malloc基本上是申请不下来的。再看malloc(0),返回的是一个不确定的指针，有可能是NULL，也有可能是一个无法被解引用的指针；翻看C++参考有如下的描述： If size is zero, the return value depends on the particular library implementation (it may or may not be a null pointer), but the returned pointer shall not be dereferenced. 表明malloc(0)是跟据，不同库的设置有着不同的表现，翻翻glibc(是GNU发布的c运行库,linux系统中最底层的api)的源码瞅瞅，有如下的说明： If n is zero, malloc returns a minumum-sized chunk. (The minimum size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit systems.) On most systems, size_t is an unsigned type, so calls with negative arguments are interpreted as requests for huge amounts of space, which will often fail. The maximum supported value of n differs across systems, but is in all cases less than the maximum representable value of a size_t. 也就是说在Linux上执行 malloc(0)时，会拿到一个指向一小块内存的指针，这个指针指向的内存的大小是由机器决定的。这里不再细究，有兴趣可以参考: 当你 malloc(0) 时会发生什么 1.2 realloc函数void *realloc(void *mem_address, unsigned int newsize);作用：重新申请内存空间，不影响原有数据，但是新分配的地址可能不一样。 realloc 1、当mem_address为null，size不为0，则realloc()和malloc()类似。分配一个newsize的内存块，返回一个指向该内存块的指针；如果没有足够可用的内存用来完成重新分配，则返回null而原来的内存块保持不变； 2、将分配的内存扩大，则有以下情况：（1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针；（2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。（3）如果申请失败，将返回NULL，原来的指针仍然有效； 3、如果内存减少，则仅改变下索引信息，但并不代表被减少的部分内存还可以安全访问，这己经释放； 4、如果newsize大小为 0，行为是未定义的，受具体实现来说， 目前VC++是相当于free(ptr)，并返回一个空指针，具体描述。 If there is not enough memory, the old memory block is not freed and null pointer is returned. If ptr is NULL, the behavior is the same as calling malloc(new_size). If new_size is zero, the behavior is implementation defined (null pointer may be returned (in which case the old memory block may or may not be freed), or some non-null pointer may be returned that may not be used to access storage). 【参考文献】： 1、https://en.cppreference.com/w/c/memory/realloc 2、https://en.cppreference.com/w/c/memory/malloc]]></content>
      <categories>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows下基于python的Tensorflow环境搭建]]></title>
    <url>%2F2020%2F05%2F17%2Fwindows%E4%B8%8B%E5%9F%BA%E4%BA%8Epython%E7%9A%84Tensorflow%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[windows下搭建python的tensorflow环境，最简单地是利用pip安装。 1. 环境准备下载python，setuptools，pip. 安装python后在，将python.exe所在的路径添加到环境变量中，1D:\Python\Python37 假设python.exe所在的路径 从pypi源上下载setuptools，下载压缩包版本的，解压之后，将setuptools拷贝到python安装路径下的tool路径下即可。1D:\Python\Python37\Tools 假设python的tools路径 从pypi源上下载pip，下载压缩版本，解压之后，打开windows的cmd，在cmd里面cd到pip-20.1.tar.gz解压（假设是这个版本）文件所在的路径中，安装pip:python setup.py install. 2. 切换pypi源默认的pypi源，由于服务器在国外，蜗牛一样的下载速度，试过的同学非常清楚；解决这个下载慢的问题，将默认的pypi源到国内的镜像；建议切换到阿里云的镜像，稳定快速； pypi源 地址 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科大 https://mirrors.ustc.edu.cn/pypi/web/simple/ 豆瓣 https://pypi.doubanio.com/simple/ 阿里云 https://mirrors.aliyun.com/pypi/simple/ 打开cmd输入set，找到USERPROFILE所在的路径，这个路径一般是用户的目录;在这个路径下创建一个pip文件夹在文件夹里面创建一个pip.ini文件，文件里面写入镜像地址。123[global]trusted-host=aliyun.comindex-url=https://mirrors.aliyun.com/pypi/simple 3. 安装virtualenv虚拟化环境会不会有人问为啥要安装虚拟化环境，这个根据个人喜好和使用习惯来定。有虚拟化环境之后可以创建多个不同的配置的环境，可以在虚拟化的环境中装各种不同场景不同配置的应用，相互不影响。linux/mac可参考：Virtualenv 的理解和使用以管理员权限打开cmd，安装virtualenv， 安装virtualenv， pip install virtualenv; 在一个路径创建一个存放虚拟环境的路径，这里用了E:\python_lib这个路径 用命令virtualenv web创建虚拟化环境; 激活该环境,window使用cd web进入当前目录下的web中，然后用Scripts\activate激活; 4. 安装tensorflow由于笔者的pc是渣渣，这里只能安装cpu版本的tensorflow，进入想要安装的虚拟化环境之后，直接安装tensorflow1pip install tensorflow-cpu==2.1 指定到cpu版本的2.1版本，当然也可以不指定 安装完成之后进入：进入python 输入：import tensorflow as tf 看是否正常，无报错说明可以安装好了。然后就可以嗨皮的使用tensorflow了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++关键特性浅析]]></title>
    <url>%2F2020%2F05%2F12%2FC%E5%92%8CC-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1. 命名空间namespace与staticnamespace的是前世今生，在C语言中定义了3个层次的作用域，即文件(编译单元)、函数和复合语句。C++引入了类作用域，类是出现在文件内的。在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。全局变量的作用域是整个程序，在同一作用域中不应有两个或多个同名的实体，包括变量、函数和类等。在程序设计中，只要小心注意，可以争取不发生错误。但是，大型的应用软件，往往不是由一个人独立完成的，而是若干人合作完成的，不同的人分别完成不同的部分，最后组合成一个完整的程序。假如不同的人分别定义了类，放在不同的头文件中，在主文件(包含主函数的文件)需要用这些类时，就用#include命令行将这些头文件包含进来。由于各头文件是由不同的人设计的，有可能在不同的头文件中用了相同的名字来命名所定义的类或函数，这样就会产生命名冲突。在程序中还往往需要引用一些库(包括C++编译系统提供的库、由软件开发商提供的库或者用户自己开发的库)，为此需要包含有关的头文件。如果在这些库中包含有与程序的全局实体同名的实体，或者不同的库中有相同的实体名，则在编译时就会出现名字冲突。C 语言和早期的C++语言没有提供有效的机制来解决这个问题，没有使库的提供者能够建立自己的命名空间的工具。人们希望ANSI C++标准能够解决这个问题，提供—种机制或者工具，使由库的设计者命名的全局标识符能够和程序的全局实体名以及其他库的全局标识符区别开来。这个时候namespace就应运而生了。【namespace支持跨文件】 什么是命名空间？ 一个由程序设计者命名的内存区域，程序设计者可以根据需要指定一些有名字的空间域，把一些全局实体分别放在各个命名空间中，从而与其他全局实体分隔开来。 命名空间的作用建立一些互相分隔的作用域，把一些全局实体分隔开来。 命名空间的定义namespace ns1 {int a；double b; void fun() { //do something};} 使用命名空间成员命名空间名：：命名空间成员名，例如 std::vector 命名空间的使用 (1)使用命名空间中的全部成员using namespace std;在本作用域(using语句所在的作用域)中引入命名空间std所有的成员的声明，以备使用；(2)使用命名空间中的特定成员;using后面的命名空间成员名必须是由命名空间限定的名字。using std::string;在本作用域(using语句所在的作用域)中引入命名空间std成员string的声明以备使用；也就是在使用了无命名namespace的文件中，使用命名空间中的成员，不必(也无法)用命名空间名限定。 无名的命名空间 C++还允许使用没有名字的命名空间，由于命名空间没有名字，在其他文件中显然无法引用，它只在本文件的作用域内有效。 1.1 编译属性在C中，给变量(局部/全局变量)、函数，加上 static表示当前函数和变量的linkage 为 internal，也就是对外部不可见, 这样就可以在不同的unit(源一般指当前文件) 中定义同名的函数和变量了。在C++中，在不同的编译unit中定义同名的函数和变量的，这样就有了命名空间namespace，解决了变量和函数名字冲突问题，同时给函数和变量限定为 internal linkage。 1.2 static 修饰的对象成员和成员函数static修饰的对象成员不能通过调用构造函数来进行初始化，因此static修饰的数据成员必须在类外进行初始化且只会初始化一次。【静态变量内存分配在 .data段】static修饰的成员函数为静态成员方法，静态成员方法可以在类内或类外定义，但必须在类内声明；；static成员方法没有this指针，不能直接引用非static数据成员或调用类的非static成员方法，只能调用类的static成员数据和static成员方法；static成员不是任何对象的组成，不依赖对象的调用所以static成员方法不能被声明为const，因为const只限定该类的对象；static成员方法不能同时被声明为虚函数。 参考文献： https://www.cnblogs.com/skullboyer/p/10200039.html https://www.cnblogs.com/JefferyZhou/archive/2012/09/24/2700306.html 2. 虚函数表vtbl与（虚）函数表指针vptr虚函数表：存储虚函数信息的表； 虚函数表指针：指向虚函数表的指针。 2.1 无虚函数的类讲C++的虚函数表之前，先看一下C语言是如何实现一个面向对象的类。12345678910111213141516// 方法1#include&lt;stdio.h&gt;typedef struct&#123; int height; int age; void (*func)(struct* stu);&#125; student;void profile(struct* stu) &#123;printf(&quot;height:%d age:%d\n&quot;, stu.height, obj-&gt;age);&#125;&#125;int main() &#123; student jhon; jhon.height = 170; jhon.age = 20; jhon.func = profile;&#125; 要有面向对象的效果，只能给struct里面添加函数指针，然后把函数赋值给指针；实际使用中这种用法比较少，主要因为函数指针的空间成本；每实例化一个结构体对象，就会有一个函数指针，例如8字节吗，如果有这个对象有m个函数指针，n个实例对象，那么消耗额外的内存是m*8*n字节。因此C语言通常不这样用，而是直接用外部定义一个函数。 123456789101112131415// 方法2#include&lt;stdio.h&gt;typedef struct&#123; int height; int age;&#125; student;void profile(struct* stu) &#123;printf(&quot;height:%d age:%d\n&quot;, stu.height, obj-&gt;age);&#125;&#125;int main() &#123; student jhon; jhon.height = 170; jhon.age = 20; profile(&amp;jhon);&#125; 对于一个C++的类， 123456789101112131415#include&lt;stdio.h&gt;class student&#123;public: int height; int age; void profile() &#123;printf(&quot;height:%d age:%d\n&quot;, height, age);&#125;&#125; ;&#125;int main() &#123; student jhon; jhon.height = 170; jhon.age = 20; jhon.profile();&#125; 跟C语言实现对比，看着像第一种方式通过在结构体定义函数指针的方式来实现。但实际相当于第二种方式。为什么呢？C++中类的操作和封装只是针对程序员的，而编译器还是面向过程的，编译器会给类的成员函数添加额外的类指针参数，在运行期间传入对象实际的指针。这说明类的数据成员和成员函数是分离的。每个函数都有一个地址（指针），不论这个函数是全局函数还是类的成员函数；在类不含虚函数的情况下，编译器在编译的时候就会把函数的地址确定下来，运行期间直接去调用这个地址的函数，这就是静态绑定方式（static binding）的函数调用。 2.2 有虚函数的类为什么会出现虚函数？为了解决面向对象中多态的实现。1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;class student&#123;public: int height; int age; virtual void profile() &#123;printf(&quot;height:%d age:%d\n&quot;, height, age);&#125;&#125; ;class seniorStu: public student&#123;public: int height; int age; string address; virtual void profile() &#123;printf(&quot;height:%d age:%d\n address:%s&quot;, height, age, address.c_str());&#125;&#125; ;int main() &#123; student bob(185,20); seniorStu jhon(170,25,&quot;四川成都&quot;); jhon.profile(); // 输出 height: 170 age:25 address:四川成都 bob.profile(); // 输出 height: 185 age:20 student* jim = &amp;jhon; jim-&gt;profile(); // 输出 height: 170 age:25 student&amp; tom = &amp;jhon; tom.profile(); // 输出 height: 170 age:25 return 0;&#125; 上述，可以看到用父类指针指向子类的地址，最终调用的profile函数韩式子类的这个现象称之为动态绑定（dynamic binding）后者说延迟绑定（lazy binding）。这里如果把子类的virtual，这个代码将调用父类的profile，输出： 输出 height: 170 age:25 输出 height: 170 age:25 这是由于类的数据成员和函数成员是分离的。 2.3 虚表指针和虚函数表从内存布局上，只能看到成员变量，看不到成员函数。因为在编译的时候就确定调用哪个函数。将了这么多，可以回归到整体函数虚函数表了，也就是C++多态的实现。 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;iostream&gt;class student&#123;public: int height; int age; virtual void profile() &#123; printf(&quot;height:%d age:%d\n&quot;, height, age);&#125; virtual void status() &#123; std::cout&lt;&lt;&quot;just student&quot;;&#125; &#125;&#125; ;class seniorStu: public student&#123;public: int height; int age; string address; virtual void profile() &#123; printf(&quot;height:%d age:%d\n address:%s&quot;, height, age, address.c_str());&#125; virtual void status() &#123; std::cout&lt;&lt;&quot;senior student&quot;;&#125;&#125; ;int main() &#123; student bob(185,20); seniorStu jhon(170,25,&quot;四川成都&quot;); jhon.profile(); // 输出 height: 170 age:25 address:四川成都 bob.profile(); // 输出 height: 185 age:20 student* jim = &amp;jhon; jim-&gt;profile(); // 输出 height: 170 age:25 student&amp; tom = &amp;jhon; tom.profile(); // 输出 height: 170 age:25 return 0;&#125; 这个示例父类有两个虚函数，子类重载了这两个虚函数。查看编译器的内存布局，clang有个命令可以输出对象的内存布局（不同编译器内存布局未必相同）， clang -cc1 -fdump-record-layouts -stdlib=libc++ student.cpp 可以看到类似于这样的内存分布：12345678910111213*** Dumping AST Record Layout 0 | class student 0 | (student vtable pointer) x | int height x | int age*** Dumping AST Record Layout 0 | class seniorStu 0 | class student (primary base) 0 | (student vtable pointer) x | int height x | int age x | string status 在父类student的起始位置有一个student vtable pointer；子类seniorStu是在他的基础上多了自己的成员status。对于含有虚函数的类，在编译期间编译器会给这种类自动的在起始位置添加一个虚表指针（vptr），让虚表指针vptr指向一个虚表；虚表中存储了实际的函数地址。那么虚表里面存储了那些详细的内容呢？ g++有打印虚表的操作（请在Linux上使用g++）会自动写到一个文件里： g++ -fdump-class-hierarchy student.cpp 可以看出如果vptr指向的并不是虚表的表头而是表头加偏移量而获得一个地址，也就是虚函数的位置。123456789101112131415161718192021222324252627Vtable for studentstudent::_ZTV7student: 4u entries 0 (int (*)(...))0 8 (int (*)(...))(&amp; _ZTI7student) 16 (int (*)(...))student::profile 24 (int (*)(...))student::statusClass student size=24 align=8 base size=20 base align=8 student (0x0x7f9b1fa8c960) 0 vptr=((&amp; student::_ZTV7Actress) + 16u)Vtable for Sensei seniorStu::_ZTV6seniorStu: 4u entries 0 (int (*)(...))0 8 (int (*)(...))(&amp; _ZTI6seniorStu) 16 (int (*)(...))seniorStu::profile 24 (int (*)(...))seniorStu::statusClass seniorStu size=24 align=8 base size=24 base align=8 seniorStu (0x0x7f9b1fa81138) 0 vptr=((&amp; seniorStu::_ZTV6seniorStu) + 16u) student (0x0x7f9b1fa8c9c0) 0 primary-for seniorStu (0x0x7f9b1fa81138) 2.4 总结一下1、如果一个类中有一个虚函数，这个类就有一个虚函数表。虚函数表示类的，而不是属于对象的，在编译时就确定了，存放在只读的数据段（非代码段）。每实例化一个类对象都有一个虚函数表指针，指向类的虚函数。虚函数表指针属于类的对象。存放在堆上或者栈上(什么时候存放在堆，什么时候存放在栈上需要再探讨一下)。2、对于有派生子类的情况：如果基类有虚函数，不管派生类实现或者没有虚函数，都有虚函数表。基类的虚函数表和派生类的虚函数表不是同一个表。如果派生类没有重写基类的函数，则派生类的虚函数表和基类的虚函数表内容是一样的。如果派生类重写了基类的虚函数，则培生累的虚函数表中用的是派生类的函数。3、对于多继承的情况，含有虚函数的基类有多少个，派生类就有多少个虚函数表；派生类有的而基类没有的，添加在派生类的第一个虚函数表中，虚函数表的结果是*表示还有下一个虚函数表，结果是0表示是最后一个虚函数表。 参考文献： https://www.zhihu.com/question/389546003/answer/1194780618 https://blog.csdn.net/weixin_30552635/article/details/99157190 3. C/C++的内存分布 内存区 用途 申请释放方式 栈区 存储局部和临时变量，函数调用时存储函数调用时，存储函数的返回指针用于控制函数的调用和返回 程序开始是自动分配内存，结束自动释放 堆区 存储动态内存分配 程序员手动申请，手动释放；若程序员不释放，在程序结束是，系统回收 BSS段 存储未初始化的变量数据，包括初始化为0的全局变量 只占运行时内存空间不占文件空间。在程序整个周期内，BSS段的数据一致存在 data区 存储已经初始化的变量数据，为数据分配空间，数据保存在目标文件中 —– 代码段TXT 存储程序代码的内存映射，以及函数体的二进制代码 —– 文字(只读)常量区 存字符串常量放等 程序结束后有系统释放 全局区(静态区) 全局变量和静态变量存储在一起，未初始化或者初始化为0的存在BSS，初始化不为0的全局变量或者静态变量存在此处 程序结束后由系统释放]]></content>
      <categories>
        <category>语言特性</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-状态模式]]></title>
    <url>%2F2020%2F05%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 什么是状态模式&emsp;&emsp;状态模式是一种行为型的设计模式，由一个场景类context驱动；所有的状态都通过state类继承过来。表现为如图1所示的样子。图1 状态模式类图&emsp;&emsp;状态模式允许通过改变对象内部的状态而改变对象的行为，整个对象表现得就好像修改了它的类一样。状态模式的每个状态子类中需要包含环境类（Context）中的所有方法的具体实现——条件语句。通过把行为和行为对应的逻辑包装到状态类里，在环境类里消除大量的逻辑判断，而不同状态的切换由继承（实现）State的状态子类去实现，当发现修改的当前对象的状态不是自己这个状态所对应的参数，则各个状态子类自己给Context类切换状态， 客户端不直接和状态类交互，客户端不需要了解状态。 2. 状态模式的实现案例1：开灯关灯&emsp;&emsp;灯有两种状态，开和关，非开即关。开和关组成一个状态机；状态的变迁由前一个状态的变化触发，可以理解为触发器。定义一个定义一个State类抽象灯的开和关；123456class state &#123;public: virtual void turnLightOn() &#123;&#125;; virtual void turnLightOff() &#123;&#125;; virtual ~state() &#123;&#125;;&#125;; &emsp;&emsp;对应开和关分别定义两个类onState和offState: 1234567891011121314151617class offState : public state &#123;public: offState() &#123; &#125; ~offState() &#123;&#125; void turnLightOn() &#123;cout &lt;&lt; &quot;灯开了，可以开始干活了！&quot; &lt;&lt; endl;&#125; void turnLightOff() &#123;cout &lt;&lt; &quot;灯已经关了，快点休息吧！&quot; &lt;&lt; endl;&#125;&#125;;class onState : public state &#123;public: onState() &#123;&#125; ~onState() &#123;&#125; void turnLightOn() &#123;cout &lt;&lt; &quot;灯已经开了，不用再开了！&quot; &lt;&lt; endl;&#125; void turnLightOff() &#123;cout &lt;&lt; &quot;灯关了，可以休息了！&quot; &lt;&lt; endl;&#125;&#125;; &emsp;&emsp;这两个类都通过public的方式继承state类。然后在定义一个环境context类，用来承载状态的变迁，灯的开关用枚举定义，OFF-&gt;关着灯，ON-&gt;开着灯。 12345678910111213141516171819202122232425262728293031class context &#123;private: state* currentType; offState* offSte; onState* onSte; //map&lt;type, state*&gt; stateMap;public: context() //state* offSte,state* onSte &#123; offSte = new offState(); onSte = new onState(); currentType = offSte; &#125; ~context() &#123; delete offSte; delete onSte; &#125; void turnOnLight()//开灯 &#123; currentType-&gt;turnLightOn(); currentType = onSte; &#125; void turnOffLight()//关灯 &#123; currentType-&gt;turnLightOff(); currentType = offSte; &#125;&#125;; &emsp;&emsp;这样就完成了由两个状态组成的状态模式；用main.cpp实现充当client； 1234567891011#include&quot;context.h&quot;int main()&#123; context myContext =context(); myContext.turnOnLight(); myContext.turnOnLight(); myContext.turnOffLight(); myContext.turnOffLight(); return 0;&#125; &emsp;&emsp;看一下通过上下文请求：这个与上述任何状态都没有直接连接；默认状态为关着灯，初始请求开灯，灯的状态变为ON，灯着开；第二个请求是一样的，它只输出一条消息状态并不做改变，指示正处于当前请求的状态什么也不发生。以下显示了这些请求的结果：输出结果为： 1234灯开了，可以开始干活了！灯已经开了，不用再开了！灯关了，可以休息了！灯已经关了，快点休息吧！ 案例2：有三级亮度的灯&emsp;&emsp;在正常开灯关灯的基础上增加两种状态，比如灯更亮，灯最亮的状态；按照状态模式的设计定义，我们就需要再增加两个类，分别表示更亮和最亮。相应的类的接口就需要增加一个接口；现在的状态变迁过程就是：关-&gt;亮-&gt;更亮-&gt;最亮，状态之间是单线的传递变迁。由于状态类的变迁是单向的，这里我们重构以状态类，通过turnLightSwitch()方法触发状态的变迁。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class state &#123;public: virtual void turnLightSwitch() &#123;&#125;; virtual ~state() &#123;&#125;;&#125;;class offState : public state &#123;public: offState() &#123; &#125; ~offState() &#123;&#125; void turnLightSwitch() &#123; cout &lt;&lt; &quot;灯关了，可以休息了！&quot; &lt;&lt; endl; &#125;&#125;;class onState : public state &#123;public: onState() &#123;&#125; ~onState() &#123;&#125; void turnLightSwitch() &#123; cout &lt;&lt; &quot;灯开了，可以开始干活了！&quot; &lt;&lt; endl; &#125;&#125;;class brighterState : public state &#123;public: brighterState() &#123;&#125; ~brighterState() &#123;&#125; void turnLightSwitch() &#123; cout &lt;&lt; &quot;灯更亮一档了！&quot; &lt;&lt; endl; &#125;&#125;;class brightestState : public state &#123;public: brightestState() &#123;&#125; ~brightestState() &#123;&#125; void turnLightSwitch() &#123; cout &lt;&lt; &quot;灯开到最亮了！&quot; &lt;&lt; endl; &#125;&#125;; &emsp;&emsp;那么相应的context类也需要进行调整，在构造的时候进行类的传递而不是通过外部传递构造。这样看起来更符合状态模式的设计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class context &#123;private: state* currentType; offState* offSte; onState* onSte; brighterState* brighterSte; brightestState* brightestSte;public: context() &#123; offSte = new offState(); onSte = new onState(); brighterSte =new brighterState(); brightestSte =new brightestState(); currentType = offSte; &#125; ~context() &#123; delete offSte; delete onSte; delete brighterSte; delete brightestSte; &#125; void turnOnLight()//开灯 &#123; if (currentType == offSte) &#123; currentType = onSte; currentType-&gt;turnLightSwitch(); return; &#125; cout &lt;&lt; &quot;设置错误！&quot; &lt;&lt; endl; &#125; void turnOffLight()//关灯 &#123; if (currentType == brightestSte) &#123; currentType = offSte; currentType-&gt;turnLightSwitch(); return; &#125; cout &lt;&lt; &quot;设置错误！&quot; &lt;&lt; endl; &#125; void turnOnLightBrighter() &#123; if (currentType == onSte) &#123; currentType = brighterSte; currentType-&gt;turnLightSwitch(); return; &#125; cout &lt;&lt; &quot;设置错误！&quot; &lt;&lt; endl; &#125; void turnOnLightBrightest() &#123; if (currentType == brighterSte) &#123; currentType = brightestSte; currentType-&gt;turnLightSwitch(); return; &#125; cout &lt;&lt; &quot;设置错误！&quot; &lt;&lt; endl; &#125;&#125;; 同样，这里的客户端用一个main函数模拟使用：123456789101112int main()&#123; context myContext =context(); myContext.turnOnLight(); myContext.turnOnLight(); myContext.turnOffLight(); myContext.turnOffLight(); myContext.turnOnLightBrighter(); myContext.turnOnLightBrightest(); myContext.turnOffLight(); return 0;&#125; 输出结果：1234567灯开了，可以开始干活了！设置错误！设置错误！设置错误！灯更亮一档了！灯开到最亮了！灯关了，可以休息了！ 案例3：导航矩阵&emsp;&emsp;有3*3的矩阵，也就是9个状态，不同的状态会有不同的选择；起始位置可以是其中任意一个，箭头方向表示可以运动的方向。也就是能上下左右走，但不能斜着走。首先建立状态接口，matrix，分别提供一个变迁和或者移动的方法名。因为这里虽然有9个状态，但是一个状态最多需要4个变迁。 123456789class matrix &#123;public: virtual void up() &#123;&#125;; virtual void down() &#123;&#125;; virtual void left() &#123;&#125;; virtual void right() &#123;&#125;; virtual ~matrix() &#123;&#125;;&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243class context &#123;private: cellMatrix_1* matrix_1; cellMatrix_2* matrix_2; cellMatrix_3* matrix_3; cellMatrix_4* matrix_4; cellMatrix_5* matrix_5; cellMatrix_6* matrix_6; cellMatrix_7* matrix_7; cellMatrix_8* matrix_8; cellMatrix_9* matrix_9; matrix* currentState;public: context() &#123; matrix_1 = new cellMatrix_1(); matrix_2 = new cellMatrix_2(); matrix_3 = new cellMatrix_3(); matrix_4 = new cellMatrix_4(); matrix_5 = new cellMatrix_5(); matrix_6 = new cellMatrix_6(); matrix_7 = new cellMatrix_7(); matrix_8 = new cellMatrix_8(); matrix_9 = new cellMatrix_9(); &#125; ~context() &#123; delete matrix_1; delete matrix_2; delete matrix_3; delete matrix_4; delete matrix_5; delete matrix_6; delete matrix_7; delete matrix_8; delete matrix_9; &#125; void setState(matrix* state)&#123;currentState = state;&#125; void up() &#123;currentState-&gt;up();&#125; void down() &#123;currentState-&gt;down();&#125; void left() &#123;currentState-&gt;left();&#125; void right()&#123;currentState-&gt;right();&#125;&#125;; 3. 状态模式优劣优点： 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。 使用场景： 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode刷题-排列和组合问题]]></title>
    <url>%2F2020%2F05%2F05%2Fleetcode%E5%88%B7%E9%A2%98-%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[以数组和字符串形式的例题总结，涉及到排列和组合相关问题的,主要通过递归或者循环解决问题。 1. 组合问题【从n个元素中取m个元素–子集】例题1. LeetCode-78-子集 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:输入: nums = [1,2,3]输出: [[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[] ] 题解：从数组中连续至少0个元素，构成的子集问题，可以模拟成一个层次遍历的过程；从空集合开始，然后空集合的基础上依次插入元素，先是1个元素的集合，接着是2个元素的集合，依次类推。首先，创建一个局部变量存放结果，把空集合插入存进去vector&lt;vector&lt;int&gt; &gt; res(1)；遍历整个数组，同事嵌套遍历结果数组，往结果数组中依次插入当前遍历到的数组元素，由于结果数组中有一个空子集，嵌套遍历结果数组的时候，就是往空子集中插入第1个元素，此时这个结果肯定是没有出现的排列，再把这个排列插入结果数组；这样结果中就存入了[]和[1];此时进去下一次迭代，数组的第二个元组，在依次往结果数组中的子集插入，也就是[2]依次插入[]和[1]中；以此类推，就可以遍历完所有的排列。123456789101112131415/**代码实现**/vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res(1); for(int i=0;i&lt;nums.size();i++)&#123; int cnt=res.size(); //注意这里不能用res.size(), 因为在不断的往res插入 //会导致迭代器对象操作等失效，也就是 for(int j=0;j&lt;cnt;j++)&#123; vector&lt;int&gt; tmp=res[j]; tmp.push_back(nums[i]); res.push_back(tmp); &#125; &#125; return res;&#125; 例题2. LeetCode-90-子集II 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。示例:输入: [1,2,2]输出: [[2],[1],[1,2,2],[2,2],[1,2],[]] 题解 题目中描述有重复元素，所以去重是在排列里面很关键，在上一题的基础上增加去重的操作即可，这里用一个set去去重，由于排列不考虑数的顺序，所以需要排序一下，进行归一化，然后设计一个hash表去重，这里hash表示就是unordered_map,键值用排序后的数组字符化表示； 123456789101112131415161718192021222324252627string clcHashValue(vector&lt;int&gt;&amp; nums)&#123; string res = &quot;&quot;; sort(nums.begin(),nums.end()); for(int i=0; i &lt; nums.size(); i++)&#123; res+=to_string(nums[i])+&quot;+&quot;; &#125; return res;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res(1); unordered_set&lt;string&gt; numstt; for(int i=0;i&lt;nums.size();i++)&#123; int cnt=res.size(); //注意这里不能用res.size(), 因为在不断的往res插入 //会导致迭代器对象操作等失效，也就是 for(int j=0;j&lt;cnt;j++)&#123; vector&lt;int&gt; tmp=res[j]; tmp.push_back(nums[i]); string tempHash = clcHashValue(tmp); if(numstt.find(tempHash) == numstt.end())&#123; res.push_back(tmp); numstt.insert(tempHash); &#125; &#125; &#125; return res;&#125; 2. 排列问题例题1. 面试题 08.07. 无重复字符串的排列组合 无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。示例1: 输入：S = “qwe” 输出：[“qwe”,”qew”,”wqe”,”weq”,”ewq”,”eqw”]示例2: 输入：S = “ab” 输出：[“ab”,”ba”] 题解 我们把字符串看成两部分，第一部分是它的第一个字符，第二部分是后边的字符。求整个字符串的排列，可以就可以看成两部分，首先求所有可能出现在第一个位置的字符，也就是把第一个字符和后边所有的字符交换。第二部分固定第一个字符求后面字符的排列。在第二部分的时候仍把后边的字符分成2部分，依次类推。这样就是很典型的递归了。1234567891011121314151617181920212223242526void strPerm(vector&lt;string&gt; &amp;result, string &amp;s, int beginIndex) &#123; if(beginIndex == s.size()-1) &#123; result.push_back(s); return; &#125; for(int i = beginIndex; i&lt;s.size(); i++) &#123; //交换第一个字符，交换从第一个开始，beginIndex从0开始 char temp = s[beginIndex]; s[beginIndex] = s[i]; s[i] = temp; strPerm(result, s, beginIndex+1); //下次递归前恢复刚才的交换的字符 temp = s[beginIndex]; s[beginIndex] = s[i]; s[i] = temp; &#125;&#125;vector&lt;string&gt; permutation(string s) &#123; vector&lt;string&gt; result; if(s.empty()) &#123; return result; &#125; strPerm(result, s, 0); return result;&#125; 例题2. 面试题 08.08. 有重复字符串的排列组合 有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。示例1: 输入：S = “qqe” 输出：[“eqq”,”qeq”,”qqe”]示例2: 输入：S = “ab” 输出：[“ab”, “ba”]提示: 字符都是英文字母。字符串长度在[1, 9]之间。 题解 如上题一样，这里主要去重，去重，可以简单地额用一个hash表来解决，这里用unordered_set来创建hash。 12345678910111213141516171819202122232425262728void strPermu(unordered_set&lt;string&gt;&amp; perLib, vector&lt;string&gt;&amp; res, string &amp;s, int beginIndex) &#123; if(s.size()-1 == beginIndex) &#123; if(perLib.find(s)==perLib.end()) &#123; res.push_back(s); perLib.insert(s); &#125; return; &#125; for(int i = beginIndex; i&lt;s.size(); i++) &#123; char temp = s[i]; s[i] = s[beginIndex]; s[beginIndex] = temp; strPermu(perLib, res, s, beginIndex+1); temp = s[i]; s[i] = s[beginIndex]; s[beginIndex] = temp; &#125;&#125;vector&lt;string&gt; permutation(string s) &#123; vector&lt;string&gt; result; if(s.empty()) &#123;return result;&#125; unordered_set&lt;string&gt; perLib; strPermu(perLib, result, s, 0); return result;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode刷题--典型字符串问题]]></title>
    <url>%2F2020%2F05%2F05%2FLeetCode%E5%88%B7%E9%A2%98-%E5%85%B8%E5%9E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[字符串的子串和子序列，子串必须是连续的，子序列不一定要求联系 。什么叫回文串？如果一个字符串正着读和反着读是一样的，那它就是回文串。 1. 最长回文串例题1. 409. 最长回文串 给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。示例 1:输入:b “abccccdd”输出: 7 解释: 我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。 题解： 给一个字符串，要求这个字符串的字符能构成的最长回文字符串，建立一个hash统计每个字符的数量，然后遍历hash表，如果字符的个数是偶数，则将这些偶数的字符个数加起来；然后将字符数是奇数的依次减去1，同事统计奇数的个数在奇数&gt;0的时候在累加和上+1，否则+0，得到的结果就是答案可以构成的最长回文字符串。12345678910111213141516171819202122class Solution &#123;public: int longestPalindrome(string s) &#123; if(s.size()&lt;=1)&#123;return s.size();&#125; unordered_map&lt;char,int&gt; charLibHash; for(auto &amp; ch: s)&#123; charLibHash[ch]++; &#125; int oddNum = 0; int evenNum = 0; for(auto itr = charLibHash.begin(); itr!=charLibHash.end();itr++) &#123; if(itr-&gt;second%2 == 0)&#123;evenNum+=itr-&gt;second;&#125; else&#123; if( itr-&gt;second&gt;0 ) &#123; evenNum+=itr-&gt;second-1; &#125; oddNum++; &#125; &#125; return evenNum+(oddNum&gt;0?1:0); &#125;&#125;; 例题2. 5.最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1：输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2：输入: “cbbd”输出: “bb” 题解： 方法1 字符串正着读和反着读是一样的，也就是从从回文中心两边互为镜像。因此以中心展开，只有两种可能，1是回文字符串是奇数长度，2是偶数长度；对于 n 长度的字符串，不知道它的回文串中心倒底是奇数数还是偶数，所以我们要对这两种情况都做遍历，也就是 n+(n-1) = 2n - 1，所以时间复杂度为 O(n)；当中心确定后，我们要围绕这个中心来扩展回文，那么最长的回文可能是整个字符串，所以时间复杂度为 O(n)；所以依次遍历字符串，时间复杂度为 O(n^2)。 123456789101112131415161718192021222324252627class Solution &#123;public: int palindromeLen(string&amp; s, int beginIndex, int endIndex) &#123; while(beginIndex&gt;=0 &amp;&amp; endIndex&lt;s.size() &amp;&amp; s[beginIndex] == s[endIndex])&#123; beginIndex--; endIndex++; &#125; // 以中心左右移动，计算当前的字符串长度， return endIndex-beginIndex-1; &#125; string longestPalindrome(string s) &#123; if (s.size() &lt;= 1) &#123; return s; &#125; int beginIndex = 0; int endIndex = 0; for(int i = 0; i&lt; s.size(); i++) &#123; int len1 = palindromeLen(s, i, i); int len2 = palindromeLen(s, i, i+1); int circleLen = max(len1, len2); if(circleLen &gt; endIndex - beginIndex)&#123; beginIndex = i - (circleLen - 1) / 2; endIndex = i + circleLen/2; &#125; &#125; return s.substr(beginIndex, endIndex-beginIndex+1); &#125;&#125;; 方法2 暴力法，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。假设 n 是输入字符串的长度，从字符串头尾开始依次截取字符串，检查是否为回文字符串。从头一遍循环，尾部一次遍历，中间检查是否是回文再一次遍历，因为验证每个子字符串需要 O(n)O(n) 的时间，所以运行时间复杂度是 O(n^3)。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.size() &lt;= 1) &#123; return s; &#125; string result; for (int i = s.size() - 1; i &gt;= 0; i--) &#123; int copyIndexI = i; string tempStr; if (result.size() &gt;= i+1) &#123; // s.substr(0, i + 1).size() break; &#125; for (int j = 0; j &lt;= i; j++) &#123; int copyIndexJ = j, count = 0; copyIndexI = i; while (copyIndexJ &lt;= copyIndexI) &#123; if (s[copyIndexJ] == s[copyIndexI]) &#123; if (copyIndexI == copyIndexJ) &#123; count++; &#125; else &#123; count = count + 2; &#125; copyIndexJ++; copyIndexI--; &#125; else &#123; break; &#125; &#125; if (count==(i-j+1)) &#123; tempStr = s.substr(j, i - j + 1); result = tempStr.size() &gt; result.size() ? tempStr : result; &#125; &#125; &#125; if (s.size() &gt; 1 &amp;&amp; result.empty()) &#123; return s.substr(0, 1); &#125; return result; &#125;&#125;; 例题3. 214. 最短回文串 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 示例 1:输入: “aacecaaa”输出: “aaacecaaa” 示例 2:输入: “abcd”输出: “dcbabcd” 题解： 题目要求从字符串开始添加字符，形成的最短回文字符串。方法1：暴力法：首先检查字符是不是回文字符串，如果是直接返回，若不是则依次从末尾删除字符串，每删除一个检查一遍当前字符串是否是回文字符串，如果是就将删除的字符串添加到字符串开头；否则继续重复删除和检查的动作，直至删掉n-1个字符；1234567891011121314151617181920212223242526class Solution &#123;public: int iSpaliStr(string&amp; s, int beginIndex, int endIndex)&#123; while(beginIndex &lt; endIndex) &#123; if(s[beginIndex] == s[endIndex])&#123; beginIndex++; endIndex--; &#125;else&#123;return false;&#125; &#125; return true; &#125; string shortestPalindrome(string s) &#123; if(s.empty()) &#123;return s;&#125; int endIndex = s.size()-1; for( ;endIndex &gt;0 ; endIndex--) &#123; if(iSpaliStr(s, 0, endIndex) == true) &#123; break; &#125; &#125; string temp = s.substr(endIndex+1, s.size() - endIndex-1); // 或者取s.substr(endIndex+1); 取endIndex+1至字符串结尾的子串。 reverse(temp.begin(), temp.end()); return temp+s; &#125;&#125;; 方法2：暴力升级版： 寻找从开头开始的最长回文串，然后将末尾的除去最长回文串部分的几个字符倒置后加到原字符串开头即可。将原始字符串逆序，然后比较对应的子串即可判断是否是回文串。 1234567891011121314151617181920212223242526272829303132333435**举例**abbacd原s: abbacd, 长度记为 n逆r: dcabba, 长度记为 n判断 s[0,n) 和 r[0,n)abbacd != dcabba判断 s[0,n - 1) 和 r[1,n)abbac != cabba 判断 s[0,n - 2) 和 r[2,n)abba == abba 从开头开始的最长回文串也就找到了, 接下来只需要使用之前的方法。将末尾不是回文串的部分倒置加到原字符串开头即可。class Solution &#123;public: string shortestPalindrome(string s) &#123; if(s.empty()) &#123;return s;&#125; string str = s; reverse(str.begin(), str.end()); int index = 0; int len = s.size(); for(;index&lt; len;index++) &#123; string strOtr = s.substr(0, len-index); string strRev = str.substr(index); if(strOtr == strRev)&#123; break; &#125; &#125; string strtemp = s.substr(len - index); reverse(strtemp.begin(), strtemp.end()); return strtemp+s; &#125;&#125;; 参考方法：[1]. https://leetcode-cn.com/problems/shortest-palindrome/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--44/ 2. 公共子序列&amp;公共子串子串和子序列问题，是类似的问题，常规方法深度遍历或者动态规划方法。先介绍动态规划方法，按照常规套路，1、绘制网格；2、填充网格；3、归纳状态转移公式；例子1： hish和fish123456公共子串 公共子序列- | f | g | s | h | - | f | g | s | h | f | 1 | 0 | 0 | 0 | f | 1 | 1 | 1 | 1 |i | 0 | 0 | 0 | 0 | i | 1 | 1 | 1 | 1 |s | 0 | 0 | 1 | 0 | s | 1 | 1 | 2 | 2 |h | 0 | 0 | 0 | 2 | h | 1 | 1 | 2 | 3 | 转移公式，1234567891011== 公共子串 ==if word_a[i] == word_b[j]: ---&gt;两个字母相同 cell[i][j] = cell[i-1][j-1]+1else: cell[i][j] = 0== 公共子序列 == if word_a[i] == word_b[j]: ---&gt;两个字母相同 cell[i][j] = cell[i-1][j-1]+1else: cell[i][j] = max(cell[i-1][j], cell[i][j-1]) 例题1. 516. 最长回文子序列 给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。 示例 1:输入:“bbbab”输出:4一个可能的最长回文子序列为 “bbbb”。 示例 2:输入: “cbbd”输出: 2一个可能的最长回文子序列为 “bb”。 题解： 求字符串的最长回文序列，理解一下回文，就是正反念都一样，那么把字符串颠倒一下，求回文子序列就相当于求字符串和它的翻转字符串公共子序列。用动态规划求解， 状态：f[i][j] 表示 s 的第 i 个字符到第 j个字符组成的子串中，最长的回文序列长度是多少； 转移方程：如果 s 的第 i 个字符和第 j 个字符相同的话dp[i][j] = dp[i + 1][j - 1] + 2如果 s 的第 i 个字符和第 j 个字符不同的话dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 参考方法：[1]. https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-si-yao-su-by-a380922457-3/[2]. https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/jian-dan-zhi-jie-de-dong-tai-gui-hua-by-ha-di-2/123456789101112131415161718192021222324252627282930class Solution &#123;public: int longCommStr(vector&lt;vector&lt;int&gt;&gt;&amp; dp, string&amp; str1, string&amp; str2) &#123; for(int i = 1; i &lt;= str1.size(); i++) &#123; for(int j = 1; j &lt;= str2.size(); j++) &#123; if(str1[i-1] == str2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[str1.size()][str2.size()]; &#125; void initDpArr(vector&lt;vector&lt;int&gt;&gt;&amp; dp, int Len)&#123; for(int i = 0; i&lt;= Len; i++)&#123; dp[0][i] = 0; dp[i][0] = 0; &#125; &#125; int longestPalindromeSubseq(string s) &#123; if(s.size()&lt;=1) &#123;return s.size();&#125; string str = s; reverse(str.begin(), str.end()); vector&lt;vector&lt;int&gt;&gt; dynamicsp(s.size()+1, vector&lt;int&gt;(s.size()+1)); initDpArr(dynamicsp, s.size()); return longCommStr(dynamicsp, s, str); &#125;&#125;; 例题2. 1143. 最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。若这两个字符串没有公共子序列，则返回 0。 示例 1:输入：text1 = “abcde”, text2 = “ace”输出：3解释：最长公共子序列是 “ace”，它的长度为 3。 示例 2输入：text1 = “abc”, text2 = “abc”输出：3解释：最长公共子序列是 “abc”，它的长度为 3。 示例 3:输入：text1 = “abc”, text2 = “def”输出：0解释：两个字符串没有公共子序列，返回 0。 提示:1 &lt;= text1.length &lt;= 10001 &lt;= text2.length &lt;= 1000输入的字符串只含有小写英文字符。 题解： 动态规划，直观遍历12345678910111213141516171819202122232425class Solution &#123;public: int longCommStr(vector&lt;vector&lt;int&gt;&gt;&amp; dp, string&amp; str1, string&amp; str2) &#123; for(int i = 1; i &lt;= str1.size(); i++) &#123; for(int j = 1; j &lt;= str2.size(); j++) &#123; if(str1[i-1] == str2[j-1]) &#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = max(dp[i-1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[str1.size()][str2.size()]; &#125; void initDpArr(vector&lt;vector&lt;int&gt;&gt;&amp; dp, int Len)&#123; for(int i = 0; i&lt;= Len; i++)&#123; dp[0][i] = 0; dp[i][0] = 0; &#125; &#125; int longestCommonSubsequence(string text1, string text2) &#123; vector&lt;vector&lt;int&gt;&gt; dynamicsp(text1.size()+1, vector&lt;int&gt;(text2.size()+1)); return longCommStr(dynamicsp, text1, text2); &#125;&#125;;]]></content>
      <categories>
        <category>函数指针</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从函数指针看C语言的面向对象实现]]></title>
    <url>%2F2020%2F05%2F05%2F%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9C%8BC%E8%AF%AD%E8%A8%80%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1. 什么是函数指针指针函数：指针函数本质是一个函数，只不过返回值为某一类型的指针（地址值）。函数返回值必须用同类型的变量来接受，也就是说，指针函数的返回值必须赋值给同类型的指针变量。函数指针：函数指针本质是一个指针，只不过这个指针指向一个函数。指针变量通畅指向一个整形、字符型、或者数组等变量，而函数指针指向的是函数。常见的函数都有其入口，比如 main() 函数是整个程序的入口，我们调用的其他函数都有其特定的入口，正如我们可以通过地址找到相应的变量一样，我们也可以通过地址找到相应的函数。而这个存储着函数地址的指针就是函数指针。可以通过指针访问相应的变量，函数指针也可以像函数一样用于调用函数、传递参数。回调函数函数指针作为某个函数的参数。理解回调函数，我们先要搞清楚回调函数有什么作用。比如老板、经理、你三个角色。老板通常是规则的指定着，经理按照规则指派相应的人去做事，而你就是任务的具体执行者。当老板要求经理去做一个事情，那么老板就是主调函数，经理就是回调函数，你按照规则去处理事情就是相应回调函数。你处理的结果会反馈给经理，经理拿着你的结果再反馈给老板。老板就可以使用这个结果去做相关的事情了。在这个环节中，你只需要按照指定的规则去做事，而经理不需要考虑事情是怎么做的，他只需要把相应的事情分配给对应的人去处理即可，然后将获取的结果反馈给老板。如果规则有变，只需要对应的员工知道哪里改变了，而经理不需要关注这些细节。函数指针的应用场景 普通的函数指针，指向函数，实现比如勾子函数等 回调函数，实现在特定情况下需要不同的处理，或者对不同些数据的不同处理 封装，函数模板，构造对象（类似于C++虚函数）等等 结构体，是定义了一个用户自定义内型，那么这个内型就可以定义N多的变量，不同的变量拥有不同的值，也包括函数指针的值，这样就实现了”多态”，模拟OOP中的虚函数。函数指针声明 函数原型int sum(int,int);是一个返回值为int类型, 参数是两个int类型的函数. 如何声明该类型函数的指针呢？将函数名替换成(pf)形式即可，即我们把sum替换成(fp)即可，fp为函数指针名int （*fp）(int,int); 这样就声明了和sum函数类型相同的函数指针fp, *和fp为一体，说明了fp为指针类型; *fp需要用括号括起来，否则就会变成int *fp(int,int);,这时候意义就变化了，成立一个返回值为一个int指针类型的函数，函数一个函数指针。为了避免每次声明函数指针的时候方便，函数指针可以用typedef定义：12typedef int (*myFun)(int,int);//为该函数指针起一个新名字myFun f1; //声明myFun类型的函数指针f1 函数指针赋值1234567891011121314#include&lt;stdio.h&gt;int mytest(int a,int b)&#123; return a+b;&#125;typedef int(*fp)(int,int);int main(void)&#123; fp func1 = mytest; //表达式1 fp func2 = &amp;mytest;//表达式2 printf(&quot;%d\n&quot;,func1); printf(&quot;%d\n&quot;,func2); return 0;&#125; 这里，声明返回类型为int，接受两个int类型参数的函数指针func1和func2，分别给它们进行了赋值。表达式1和表达式2在作用上是一样的。由于函数名在被使用时总是由编译器把它转换为函数指针，因此前面加上&amp;只是显式的说明了这一点而已。 函数指针的调用 12345678910111213#include&lt;stdio.h&gt;int mytest(int a,int b)&#123; return a+b;&#125;typedef int(*fp)(int,int);int main(void)&#123; fp func = mytest; //表达式1 func(1,2); //表达式1 (*func)(3,4); //表达式2 return 0;&#125; 在函数指针后面加括号，并传入参数即可调用，其中表达式1和表达式2似乎都可以成功调用，但是哪个是正确的呢？ANSI C认为这两种形式等价。 2. 函数指针的用途1、作为句柄函数传入，以库函数qsort排序函数为例， 1void qsort(void *base,size_t nmemb,size_t size , int(*compar)(const void *,const void *)); 拆开来看如下：1void qsort(void *base, size_t nmemb, size_t size, ); 拿掉第四个参数后，它是一个无返回值的函数，接受4个参数，第一个是void*类型，代表原始数组，第二个是size_t类型，代表数据数量，第三个是size_t类型，代表单个数据占用空间大小，而第四个参数是函数指针。这第四个参数，即函数指针指向的是什么类型呢？1int(*compar)(const void *,const void *) 这是一个接受两个const void*类型入参，返回值为int的函数指针。这个参数告诉qsort，应该使用哪个函数来比较元素，即只要我们告诉qsort比较大小的规则，就可以帮我们对任意数据类型的数组进行排序。 结构体中包含函数指针,可以像一般变量一样,包含函数指针变量.下面是一种简单的实现1234567891011121314struct opt &#123; int x,y; int (*func)(int,int); //函数指针 &#125;; void main() &#123; struct opt demo; demo.func=add2; //结构体函数指针赋值 //demo.func=&amp;add2; //结构体函数指针赋值 printf(&quot;func(3,4)=%d\n&quot;,opt.func(3,4)); demo.func=add1; printf(&quot;func(3,4)=%d\n&quot;,opt.func(3,4)); &#125; C语言中的struct是最接近类的概念，但是在C语言的struct中只有成员，不能有函数，但是可以有指向函数的指针，们使用函数。12345678910111213141516171819202122232425262728typedef struct student &#123; int id; char name[50]; void (*init)(); void (*process)(int id, char *name); void (*destroy)(); &#125;stu; void init() &#123; /*do something*/ &#125; void process(int id, char *name) &#123; /*do something*/ &#125;void destroy() &#123; /*do something*/ &#125; int main() &#123; stu *stu1 = (stu *)malloc(sizeof(stu)); stu1-&gt;id=1000; strcpy(stu1-&gt;name,&quot;C++&quot;); stu1-&gt;init=init; stu1-&gt;process=process; stu1-&gt;destroy=destroy; printf(&quot;%d\t%s\n&quot;,stu1-&gt;id,stu1-&gt;name); stu1-&gt;init(); stu1-&gt;process(stu1-&gt;id, stu1-&gt;name); stu1-&gt;destroy(); free(stu1); return 0; &#125; 3. 函数指针的面向对象应用函数指针是解耦对象关系的最佳利器。 3.1 命令模式命令模式通过增加中转数据结构，使命令下达和命令执行二者依赖于接口，从而达到二者时间上不相关、二者变化方向独立的目的。【好处：代码清晰明了，容易添加和删除，易维护】 12345678910111213141516171819202122232425typedef struct &#123; uint8_t cmd; void (* handle)(char *buffer);&#125; package; static const package packageItems[] =&#123; &#123;0x01, parse_temperature&#125;, &#123;0x02, parse_humidity&#125;, &#123;0x03, parse_illumination&#125;, &#123;0xFF, NULL&#125;,&#125;;static uint8_t parse(void *buffer, uint16_t length)&#123; package *frame = (package *)buffer; if (frame == NULL) &#123; // 异常处理 &#125; const package *entry; for (entry = packageItems; entry-&gt;handle != NULL; ++entry) &#123; if(frame-&gt;cmd == entry-&gt;cmd) &#123; entry-&gt;handle(frame-&gt;data); break; &#125; &#125;&#125; 什么时候会用到这个命令模式呢？ 按键处理 协议解析（串口，网口，CAN，等等） 3.2 策略模式12345678910111213141516//开关配置过程typedef void (*ProcStrategy)();ProcStrategy procStrategy;if (strategy == A)&#123; procStrategy = ProcStrategyA;&#125;else&#123; procStrategy = ProcStaregyB;&#125;//核心逻辑处理过程...procStrategy();... 3.3 观察者模式函数需要抽象出来一个action函数123456789101112131415void Eat() &#123; // do something&#125;void Drink() &#123; // do something&#125;void Rest() &#123; // do something&#125;typedef void (*lAction)();lAction flikuiAction[3] = &#123;Eat, Drink, Rest&#125;;//命令响应程序void DoCmd(Cmd *cmd)&#123; for(int i = 0; i &lt; cmd-&gt;cmdNum; i++) &#123; flikuiAction[cmd-&gt;cmd[i]](); &#125;&#125; 3.4 状态模式有这么一个需求，宋江命令李逵杀敌，李逵此时有很多种状态，李逵要根据自己不同的状态做出不同的反应：如果正在吃饭，就扔掉碗进入空闲态，如果处于空闲，就拿起斧子进入战斗状态，如果处于战斗状态，就不做响应。12345678910111213typedef void (*LikuiDoAction)();LikuiDoAction likuiDoAction[3][3] = &#123; /* EATING */ /* FIGHTING */ /* IDLE *//* EAT */ &#123;DoNothing, ThrowAxe, TakeBowl&#125;,/* FIGHT */ &#123;ThrowBowl, DoNothing, TakeAxe&#125;,/* IDLE */ &#123;ThrowBowl, ThrowAxe, DoNothing&#125;&#125;void LikuiAction()&#123; likuiDoAction[SongjiangCmd][LikuiStatus]();&#125; 4. 函数指针与函数调用的性能分析直观上看应该是函数调用开销更小。函数指针调用方案中需要先访问数据区，再访问函数，增加指令开销，同时，数据取值与函数指令加载必须串行执行，影响CPU流水性能；函数调用方案可以做内联优化。]]></content>
      <categories>
        <category>函数指针</category>
      </categories>
      <tags>
        <tag>函数指针</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习资源收集]]></title>
    <url>%2F2018%2F10%2F14%2F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1、Python1）Python_交互式的学习资源2）Python生成动态图表3）Python文章中精选Top104）忘了Python关键语句？这份备忘录拯救你的记忆5）Python教程：17个冷门但实用的小技巧 2、机器学习相关1）通俗理解PCA降维作用2）18年9月机器学习开源项目Top103）LSTM和GRU的解析4）算法和编程面试题精选TOP505）5种回归损失函数6）精选机器学习文章Top107）如何通过引入硬注意力机制来学习视觉问答任务？8）深度学习必备数学知识之线性代数篇9）构建深度神经网络的实用技巧10）ICML2018见闻 | 迁移学习、多任务学习领域的进展11）8 个超赞的深度学习课程12）合成注意力推理神经网络-Christopher Manning-ICLR201813）李宏毅-201806-中文-Deep Reinforcement Learning精品课程 &emsp;提取码：3eig14）最新深度学习面试题目及答案集锦15）MIT 6.S094 深度学习与自动驾驶课程（下）16）迁移学习在自然语言处理中的应用之通用语言建模17）图说卡尔曼滤波_一份通俗易懂的教程18)）面试了10家公司，以下是一份机器学习面试内容总结19）献给新手的深度学习综述 | 入门20）https://zhuanlan.zhihu.com/p/46396329 3、Git相关1）泪流满面的 11 个 Git 面试题 4、图像处理&amp;计算机视觉1）从R-CNN到RFBNet，目标检测架构5年演进全盘点2）CNN图像分割简史：从R-CNN到Mask3）图像超级补全效果惊艳（附代码）4）用神经网络操纵图像中的自然场景属性 5、文本相关1、基于深度学习的文本分类6大算法2、Scene Text Detection 6、hexo相关1）hexo命令 https://hexo.io/zh-cn/docs/commands.html Others脉冲神经网络(SNN)]]></content>
      <categories>
        <category>学习资源</category>
      </categories>
      <tags>
        <tag>coding，learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络从0到1]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%BB%8E0%E5%88%B01%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 1980年，心理学家William James出版了第一部论述人脑结构及功能的专著《心理学原理》，首次提出: “一个神经细胞受到刺激激活后可以把刺激传播到另一个神经细胞，并且神经细胞激活是所有细胞输入叠加的结果！” 为人们认识神经网络的活动打开了理论的天窗。基于这个理论假设，从1943年开始，神经网络经历的曲折荡漾的发展，经历了数次的大起大落；理论模型也从单一的神经元感知机开始，发展到包含一个隐藏的多层感知机网络，到现在已卷积神经网络为代表的深度卷积神经网络。&emsp;&emsp;本文以神经网络的发展为线索，从卷积神经网络的结构和应用两个方面进行简单阐述。 1. 什么是卷积神经网络&emsp;&emsp;认识卷积神经网络之前首先要了解两个基本的概念: 1、什么是卷积；2、什么是神经网络。 1.1 什么是卷积 从图像的角度来看卷积: 就是卷积模板在图像上滑动，把对应位置上的元素相城相加得到最终结果的过程。如果考虑翻转则就需要翻转卷积模板。 &emsp;&emsp;卷积核的大小是奇数，如3x3,5x5,7x7等；在cnn的世界里，卷积就是通过不同的卷积核，在不同的图像尺度下，滑动来计算卷积特征的。通过修改卷积核的参数，可以实现对图像进行锐化、模糊等操作，从而检测出图像中的视觉特征；训练cnn的过程，其实也是学习这些卷积和参数的过程。在有限的范围内，使用的卷积核越多，可以学习到的图像特征也就越多。 1.2 什么是神经网络&emsp;&emsp; 按照William James的观点，人工神经网络是基于神经元假设的一种数学描述，是从信息处理的角度将人脑神经元网络进行抽象，从而建立某种模型，可以让神经元按照不同的连接方式组成不同网络的一种数学方法。神经元由大量的节点连接，这个节点称之为激活函数。常见的激活函有: sigmoid、tanh和Relu; $$\begin{eqnarray}Sigmoid(x) = 1/(1+e^{-x}) \\tanh(x)=\frac{1-e^{-2x}} {1+e^{-2x}} \\relu(x)=max(0,x)\end{eqnarray}$$ 三种常用的激活函数&emsp;&emsp;而神经元数学模型就是输入向量X经过加权，通过激活函数f过滤，输出y，也就是： $$\begin{equation}y=f(w_1*x_1+w_2*x_2+b)\end{equation}$$ 这就是感知机的数学表达。$f(x)$但是它只能解决线性问题，对于非线性问题，感知机就无从下手了，比如：异或问题。为了解决非线性问题，又在感知机的基础上提出了前馈神经网络多层感知机 ；如图，给定一组特性向量:$$x=(x_1, x_2, x_3, ….)$$ 通过输入层输入到MLP网络，网络中的隐藏层，相对于增加感知机的决策平面，从而引入多个决策节点，通过级联这些神经元，就可以将原本单个感知机的线性表示表示成多个分段的线性表示，这样就将线性的问题转换成了非线性。也就是无线逼近的积分结果，这样就可以将学习特征用级联的线性表达学习复杂的非线性模式。 1.3 什么是卷积神经网络&emsp;&emsp;卷积区别于传统的前馈神经网络的重要是，多层感知机表达的前馈神经网络的每个神经元都和前一层的输入全部相连接，是一种完全连接的模式；而卷积神经网络通过卷积核与前一层的输入相连接，卷积核的尺寸(感受野)就是卷积神经网络的连接范围，是一种局部的连接的方式。&emsp;&emsp;上图中，假设输入图像是一个1000*1000的图像，左边全连接的网络有100w个隐层的神经元，每个神经元都与输入图像的每个像素相连，那么这个网络就有1000*1000*100w = 10^12个连接；右边局部连接的网络每个节点与输入图像有10*10（实际连接的卷积和尺寸是奇数）的连接，那么100w个隐层的神经元的连接个数是10*10*100w = 10^8，比全连接少了4个数量级。除此之外卷积神经网络还有另外一个特新就是权值共享。也就是在同一层的卷积核对应的参数是相同卷积核。&emsp;&emsp;上图是一个卷积的示例，左边红色为32*32*3的输入数据，蓝色部分是一层卷积网络；右边为卷积网络的神经元数学表述，是和普通的前馈神经网络相同的模型；除了卷积和全连接的区别，卷积神经网络结构也差别很大，是由卷积核的宽度、高度和卷积层数表述的一种长、宽、深度的三维模型，这里的深度就是卷积神经网络的网络层数； 1.3 卷积神经网络的基本结构&emsp;&emsp;经典的卷积神经网络是包含：输入层、卷积层、池化层、激活层、全连接层以及输出层构成的。如下图，为LeNet-5的CNN模型:]]></content>
      <categories>
        <category>卷积神经网络</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>神经网络，机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python socket编程]]></title>
    <url>%2F2018%2F07%2F22%2Fpython-socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Socket(套接字)，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。服务器端：socket()建立套接字，绑定（bind）并监听（listen），用accept（）等待客户端连接。将accept()写入死循环，每次连接一个客户端，开一个线程。一般情况下建立socket连接后服务器与客户端建立了一个管道，当关闭socket或关闭客户端的时候，会导致管道破裂信号。如果使用默认处理则会导致服务器程序退出。 0. socket函数1socket.socket(family, type, protocol) 参数： family: 套接字python家族支持AF_UNIX、AF_INET、AF_NETLINK和AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM，其中SOCK_STREAM是tcp类型的，SOCK_DGRAM是udp类型的 protocol: 一般不填默认为0. 1. 简单的样例通信样例1.1 TCP服务端TCP是面向连接的，可靠的流协议。流就是不间断的数据结构 123456789101112# for python3.Ximport sockets=socket.socket()host=socket.gethostname() #获取主机地址,xiangdangyuport=1234 #有效端口号是0-65535，低于1024的端口号是系统保留的s.bind((host,port)) #绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址s.listen(5) #开始TCP监听，操作系统可以挂起的最大连接数量；至少为1，一般设置成5即可while True: c,addr=s.accept() #被动接受TCP客户端连接,(阻塞式)等待连接的到来 print ("Go",addr) c.send(('Thank you for connecting').encode()) #发送TCP数据，将string中的数据发送到连接的套接字 c.close() #关闭套接字 &emsp;&emsp;由于Python2.x和Python3.x的区别，socket通信在3.x版本中需要适应encode()和decode()编解码,而python3.x最重要的新特性也是对文本和二进制数据做了更清晰的区分。文本用unicode编码，为str类型，二进制数据则为bytes类型。encode（编码),可以将str类型编码为bytes。decode（译码），可以将bytes类型转换为str类型。&emsp;&emsp;注意：如果不添加encode()和decode()就会报Socket TypeError: a bytes-like object is required, not &#39;str&#39;的错误，因此在发送的时候记得将数据encode()，接收的时候将数据decode() 1.2 TCP客户端12345678import sockets=socket.socket()host=socket.gethostname()port=1234s.connect((host,port))data=s.recv(1024).decode() #接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。print (s.recv(1024).decode()) 1.3 UDP服务端&emsp;&emsp;UDP是一种无连接的，不具有可靠性的数据报文协议这个是插入时间戳的例子，同理这个还可以在tcp的socket实现，各位看官自己实现吧 123456789101112131415161718# for python3.Xfrom socket import *from time import ctimehost = 'localhost'port = 12345buffersize = 1024addr=(host, port)udpSocket = socket(AF_INET, SOCK_DGRAM)udpSocket.bind(addr)while True: print('waiting for message...') data, addr = udpSocket.recvfrom(buffersize) data = data.decode() udpSocket.sendto(('[%s] %s' % (ctime(), data)).encode(), addr) print('...received form and return to:', addr)udpSocket.close() 1.4 UDP客户端123456789101112131415161718from socket import *from time import ctimehost='localhost'port=12345buffersize=1024addr=(host, port)udpClient=socket(AF_INET, SOCK_DGRAM)while True: data = input('&gt;') if not data: break udpClient.sendto(data.encode(), addr) #address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 data,addr=udpClient.recvfrom(buffersize) data = data.decode() if not data: break print(data)udpClient.close() &emsp;&emsp;综上所述，可以得到这样的结论: socket通信，服务器端 要开启一个对应udp或者tcp的scoket，在这个socket里面指定通信的端口的地址；udp服务器的socket这样起，udpScoket=socket(AF_INET, SOCK_DGRAM); 然后在udpSocket里面调用bind()方法绑定通信的地址addr=(host, port)，也就是udpSocket.bind(addr)；然后在开启一个循环通过recvfrom()方法接收udp数据，data, addr = udpSocket.recvfrom(buffersize)，发送出去的话就利用sendto()方法，udpSocket.sendto((&#39;[%s] %s&#39; % (ctime(), data)).encode(), addr)。tcp的socket相对于udp的socket是一种可靠的传输，在起socket的时候不同于udp的主要有两点，一是利用SOCK_STREAM，二是tcp的通信需要在一段时间内监听通信端口是否有数据发来，这是tcp协议所特有的。客户端 服务器端开启了socket服务之后，socket客户端需要对应服务器开启一个对应的socket客户端：tcp开udpClient=socket(AF_INET, SOCK_STREAM)，然后让这个客户端的socket连接到服务器的socket；也就是tcpClient.connect(ADDR)&#39; 这里ADDR=(host, port)udpClient=socket(AF_INET, SOCK_DGRAM)这样客户端就和服务器连接起来了；客户端样用recv()方法接收服务器的数据；用send()方法将数据发送到服务器。udp客户同tcp的方法一样，跟对应模式的socket`方法一直，端口对端口，地址对地址。 2、socketserver模块&emsp;&emsp;socketserver是标准库中的一个高级模块，用于网络客户端与服务器的实现，模块定义了一些类来处理诸如TCP、UDP、UNIX流和UNIX数据报之上的同步网络请求。；python3中，导入socketserver模块, 使用import socketserver. 在使用socketserver的时候必须说先定义一个继承BaseRequestHandler的处理类。 socketserver 模块中包含的类： BaseServer &emsp;包含服务器的核心功能与混合类(min-in)的钩子功能.这个类主用于派生,不要直接生成这个类的类对象,可以考虑使用; TCPServer/UDPServer &emsp;TCPServer基本的网络同步tcp服务器/UDPServer 基本的网络同步udp服务器; ForkingMinIn &emsp;实现了核心的进程化功能,用于与服务器类进行混合(min-in),以提供一些异步特性.不要直接生成这个类的对象; ThreadingMinIn&emsp;实现了核心的线程化功能,用于与服务器类进行混合(min-in),以提供一些异步特性,不要直接生成这个类的对象; ForkingTCPServer/ForkingUDPServer &emsp;ForkingMinIn与TCPServer的组合/ForkingMinIn 与 UDPServer的组合; BaseRequestHandler &emsp;无法创建这个类的实例，可以使用 StreamRequestHandler 和 DataStreamRequestHandler 创建类的实例； StreamRequestHandler/DataStreamRequestHandler &emsp;tcp请求处理类的一个实现/udp请求处理类的一个实现; socket线程池附表socket属性模块 服务器端套接字*通用函数 函数名 函数名 s.bind() 绑定地址（host,port）到套接字，在AF_INET下,以元组（host,port）的形式表示地址 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了 s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来客户端套接字 s.connect() 主动初始化TCP服务器连接，一般address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误 s.connect_ex() 函数的扩展版本,出错时返回出错码,而不是抛出异常 &emsp;&emsp;]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建基于hexo的github博客系统]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84github%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文以windows为生产环境，介绍以github为免费仓库和服务器，以及node.js和hexo技术为支撑免费搭建个人博客的方法。如果想让博客链接到个人域名，那就需要去单独购买域名。 1. Git安装与github仓库配置仓库配置&emsp;&emsp;Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。与常用的版本控制工具 CVS, Subversion等不同， 它采用了分布式版本库的方式， 不必服务器端软件支持。windows环境下git的安装配置以及github仓库的配置, 可参考如下博文: windows搭建git环境 2. Node.Js与Hexo安装&emsp;&emsp;Hexo使用Markdown（或其他渲染引擎）解析文章，生成静态网页, 是搭建博客环境的基础环境，hexo依赖node.js；因此，安装hexo前必须安装Node.js和Git。 2.1 下载/安装Node.js&emsp; &emsp; 去官方下载最的.msi的新可靠版本，双击安装； 2.2 下载/安装hexo&emsp;&emsp; 安装完git和node.js之后，在本地创建一个路径用来保存hexo，其实也就是自己的本地博客代码库，比如E:\github\blog；然后，打开安装的git bash切换到刚刚创建的目录，输入npm install -g hexo-cli安装hexo； 注: npm是随同Node.JS一起安装的包管理工具, 所以装好node.js就可以在git bash中使用npm工具，无需单独安装； 3. Hexo的基本配置&emsp;&emsp;Hexo 作为一个快速、简洁且高效的博客框架。在我们下载hexo后，首先要做的是初始化hexo，告诉hexo在哪里保存博客网站 初始化hexo $ hexo init [folder]，没有folder属性就默认在hexo当前的路径建立并保存网站文件。查看hexo的基本命令可以参考hexo指令； 更改hexo主题 笔者使用的next模板主题，首先切换到hexo的themes文件夹下，将主题下载下来，在hexo的文件中将原始的theme配置由landscape改为next； 1git clone https://github.com/iissnan/hexo-theme-next themes/next 部署主题 hexo路径下的git bash输入: 12hexo clean; hexo generate #清理缓存并生成文件hexo deploy #部署 配置主题 next主题的配置文件是next文件夹下的_config.yml文件 写博文 $ hexo new &lt;title&gt; 使用默认属性在source\_posts路径下，生成一个markdown文件，然后就可以在这个文件中撰写自己的博客； 4. 绑定个人域名&emsp;&emsp;购买和注册：目前国内阿里、腾讯和百度以及华为的云都有域名购买和注册的服务，笔者在腾讯云上注册了ruitear.com这个域名。一个域名一年一般几十块钱, 还提供免费的dns域名解析服务。 配置cname文件：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名，比如我添加的是ruitear.com，有且只能添加一个。 将github博客关联到自己的域名：在域名解析的地方添加三条记录，如下图所示； 注意：blog.github.io. 是我的博客仓库名；192.30.252.153,192.30.252.154是GitHub提供的IP地址。 www：解析后的域名为 www.你的域名 @：直接解析主域名 你的域名 *：泛解析，匹配其他所有域名 *.你的域名 参考文献[1] hexo中文文档：https://hexo.io/zh-cn/docs/[2] Hexo搭建的GitHub博客之优化 http://wangwlj.com/2017/09/09/blog-opti/[3] 在Github上利用hexo搭建个人博客 https://www.jianshu.com/p/9df4aba9c25a]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>blog环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python工具包之matplotlib的使用--pyplot画图]]></title>
    <url>%2F2018%2F07%2F15%2Fpython%E5%B7%A5%E5%85%B7%E5%8C%85%E4%B9%8Bmatplotlib%E7%9A%84%E4%BD%BF%E7%94%A8-pyplot%E7%94%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; Matplotlib 是一个 Python 的 2D绘图库, 使用matplotlib能够非常简单的可视化数据。在matplotlib中使用最多的模块就是pyplot。pyplot非常接近Matlab的绘图实现，而且大多数的命令及其类似Matlab。在使用Matplotlib的时候需要import这个模块：1import matplotlib.pyplot as plot &emsp;&emsp;由于matplotlib默认字体没有中文，如果想让画图的标题支持中文的显示，必须手动添加中文字体方可，以下导入SimHei字体： 12from pylab import mplmpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;] &emsp;&emsp;画图的时候还会依赖数组和矩阵等科学计算，所以会对numpy产生依赖；所以还需要import numpy；下面将以线图、柱状图、饼图、极坐标图和散点图等几种典型的图表，介绍pyplot这个模块的画图功能。 1. 单个图表的线图&emsp;&emsp;画单个线图和MATLAB，其实基本是一样的，首先选择一个X轴的范围，然后在这个范围内把[x,y]在对应的坐标区间画出来。完整的代码如下：123456789101112131415## 字体的默认设置没有中文，所以需要手动添加中文字体才能显示中文from pylab import mplmpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]import numpy as npimport matplotlib.pyplot as plot##画单个图，多根线def plotSignleImg(): x=np.arange(0,5,0.2) # X轴的范围，0-5，点的间距是0.2个单位 plot.plot(x,x**4,&apos;r&apos;,x,x*90,&apos;bs&apos;,x,x**3,&apos;g^&apos;) ## &apos;r&apos;红 &apos;bs&apos;蓝 &apos;g^&apos;绿 plot.show() # 显示画图结果 if __name__==&apos;__main__&apos;: plotSignleImg() &emsp;&emsp;效果图： 2. 多个图表在一个图&emsp;&emsp;在一个图表中画多个图，合画单个图的方式基本是一致的，唯一的区别就是，画多图的时候需要把画布分割成相应的块数，来放图表。如下例子，画两个图，需要命令plot.subplot(211)和plot.subplot(212)这两行代码中的数字前边两个必须一直，最后一个数代表图的位置，这里1表示上边的位置，2表示下边的例子。 12345678910111213## 画多个图，多根线def plotMultiImg(): x1=np.arange(0,5,0.05) x2=np.arange(0,5,0.05) plot.figure(1) #启一个画布，用来承载图表的渲染，可忽略，默认会加载 plot.subplot(211) #211 2：水平方向2个图，1：垂直方向1列，1：第1个位置 plot.plot(x1,x1**4,&apos;r&apos;,x1,x1*90,&apos;bs&apos;,x1,x1**3,&apos;g^&apos;,linewidth=2.0) plot.subplot(212) # 212 2：水平方向2个图，1：垂直方向1列，1：第2个位置 plot.plot(x2,np.cos(2*np.pi*x2),&apos;k&apos;) plot.show() &emsp;&emsp;效果图： 3. 画直方图 (柱状图))&emsp;&emsp;正态分布是大家接触最多的一种数据的呈现规则；这里以正态分布为例，介绍一下怎么画一个正态分布图的直方图；首先构造一组满足正态分布的数据，取分布在[0,1]随机的1000组数据，构造正态分布数据。x=mu+sigma*np.random.randn(1000)从标准正态分布中返回n=1000个样本值，这1000个数值的大小随机在[0,1]。 123456789101112131415def plotHitImg(): mu,sigma=100,15 x=mu+sigma*np.random.randn(1000) #从标准正态分布中返回n=1000个样本值。 bins=100 plot.hist(x,bins,normed=1,histtype=&apos;stepfilled&apos;,facecolor=&apos;b&apos;,alpha=0.75) n,bins,patches=plot.hist(x,100,normed=1,facecolor=&apos;k&apos;) #k 表示黑色 b blue g green r red c cyan m magenta y yellow w white plot.xlabel(&quot;频率&quot;) plot.ylabel(&quot;概率&quot;) plot.title(&quot;直方图示例&quot;) plot.text(40,0.028,&apos;均值=100 标准差=15&apos;) plot.axis([40,160,0,0.03]) plot.grid() plot.show() 这里plot.hist()函数中， bins将直方图的取值范围进行均等划分bings个区间； normed =1 表示将出现频次进行了归一化。 normed=0，则为频次； alpha表示直方图的透明度[0, 1] ； histtype = ‘stepfilled’ 表示去除条柱的黑色边框 , hist柱子类型 rwidth= :柱子与柱子之间的距离，默认是0 orientation:水平或垂直方向 plot.text()函数中， text(x,y,string,fontsize=15,verticalalignment=”top”,horizontalalignment=”right”) x,y:表示坐标值上的值 也就是字符串在图标的位置； string:表示说明文字 fontsize:表示字体大小 verticalalignment:垂直对齐方式，参数:[center|top|bottom|baseline] horizontalalignment:水平对齐方式，参数:[center|right|left] &emsp;&emsp;效果图： 4. 画饼图&emsp;&emsp;饼图，在分析数据时，主要呈现各份数据在总体的比例；相同颜色的数据标记组成一个数据系列。）显示为整个饼图的百分比。这里简单用水果的例子示意，总共有苹果、西瓜、猕猴桃和芒果等四种水果。它们分别占50%、12%、20%和18%。123456789def plotPieImg(): labels=[&apos;苹果&apos;,&apos;西瓜&apos;,&apos;芒果&apos;,&apos;猕猴桃&apos;] size=[50,12,18,20] explode=(0,0.0,0,0) plot.pie(size,explode=explode,labels=labels,autopct=&apos;%1.1f%%&apos;,shadow=True,startangle=90,pctdistance = 0.6) plot.axis(&apos;equal&apos;) plot.legend() #画出标签的图 plot.show() pyplot.pie()函数：patches,l_text,p_text = atplotlib.pyplot.pie() 参数 默认值 描述 x NA 数组。输入的数据用于创建一个饼图。 explode None 数组，可选参数，维度为数据项的个数，如explode=(0,0.5,0,0) 第二个突出 labels None 列表,可选参数，为每个饼块的标记。维度为数据项个数。 colors None 数组,可选参数，用来标注每块饼图的颜色。None：将使用当前活动环的颜色。 autopct None 字符串或函数，可选参数。如果不是None，是一个字符串或函数用带有数值饼图标注。 pctdistance 0.6 浮点数,可选参数,每个饼切片中心和通过autopct生成的文本开始之间的比例。如autopct是None,被忽略。 shadow False 布尔值，可选参数，在饼图下面画一个阴影。 labeldistance 1.1 浮点数，可选参数，被画饼标记的直径。 startangle None 浮点类型，可选参数，如果不是None，从x轴逆时针旋转饼图的开始角度。 radius None 浮点类型，可选参数，饼图的半径，如果半径是None，将被设置成1。 counterclock rue 布尔值，可选参数，指定指针方向，顺时针或者逆时针。 wedgeprops None 字典类型,可选参数,参数字典传递给wedge对象用来画一个饼图.如：wedgeprops={‘linewidth’:3}线宽为3。 textprops None 字典类型，可选参数，传递给text对象的字典参数。 center (0, 0) 浮点类型的列表，可选参数，图标中心位置。 frame False 布尔类型，可选参数，如果是true，绘制带有表的轴框架。 rotatelabels False 布尔类型，可选参数，如果为True，旋转每个label到指定的角度。 hold None data None 返回值：patches：列表。matplotlib.patches.Wedge实例列表。text：列表。matplotlib.text.Text实例label的列表。autotexts：列表。A是数字标签的Text实例列表。 仅当参数autopct不为None时才返回。 &emsp;&emsp;效果图： 5. 极坐标图&emsp;&emsp;先简单说一下极坐标系：在平面内取一个定点O，叫极点，引一条射线Ox，叫做极轴，再选定一个长度单位和角度的正方向（通常取逆时针方向）。对于平面内任何一点M，用ρ表示线段OM的长度（有时也用r表示），θ表示从Ox到OM的角度，ρ叫做点M的极径，θ叫做点M的极角，有序数对(ρ,θ)就叫点M的极坐标，这样建立的坐标系叫做极坐标系。通常情况下，M的极径坐标单位为1（长度单位），极角坐标单位为rad（或°）。[参考 极坐标]。因此，画极坐标图，我们需要先建一个极坐标系，ax=plot.subplot(111,projection=&#39;polar&#39;)利用subplot函数在当前的figure中建立一个极坐标系，返回针对这个subplot的一个坐标轴Axes对象。然后设置这个subplot的bar，bar(left, height, width=0.8, bottom=None, **kwargs)设置一个矩形框，大小限定在left, left+width, bottom, bottom+height的范围，left，bottom，height，width四个参数决定位置和大小left决定了左边界，bottom决定了下边界，height决定了长度，width决定了宽度。对应到笛卡尔坐标系中，left决定了扇形的中线位置，然后height决定扇形的长度，bottom决定了下边界，width决定了扇形的宽度。 numpy中random.rand()和randn() random.randn(d0, d1, …, dn)是从标准正态分布中返回一个或多个样本值 numpy.random.rand(d0, d1, …, dn)的随机样本位于[0, 1)中 1234567891011121314#面向对象的极坐标图绘制def plotPolorImg(): N=20 theta=np.linspace(0.0,2*np.pi,N,endpoint=False) #角度 radii=10*np.random.rand(N) # 随机20个[0,10]的样本 width=np.pi/4*np.random.rand(N) 随机20个[0,1]*2pi的样本，也就是 ax=plot.subplot(111,projection=&apos;polar&apos;) #建立一个坐标系，projection=&apos;polar&apos;表示极坐标 bars=ax.bar(theta,radii,width,bottom=0.0) #绘制一个条形图 #theta,radii,width分别是left，height， width for r,bar in zip(radii,bars): #循环为每个bar对象设置颜色和透明度 bar.set_facecolor(plot.cm.viridis(r/10.)) bar.set_alpha(0.5) #添加颜色 plot.show() zip()函数 将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。zip 方法在 Python2和 Python 3 中的不同：在 Python3 中为了减少内存，zip()返回的是一个对象。如需展示列表，需手动 list() 转换。bar.set_facecolor() 窗口的背景颜色bar.set_edgecolor() 窗口的边框颜色plot.cm.viridis() 蓝-绿-黄colormapset_alpha() 设置透明度，同plot的alpha参数，透明度[0, 1]alpha表示直方图的透明度[0, 1] ； &emsp;&emsp;效果图： 6. 散点图&emsp;&emsp;散点图，顾名思义就是在图中分布的各个没有连接的孤点，也就是把某些点在坐标中明晰的表示出来。在数据的二维和三维表示中，用来发现数据分类和排布很有作用。1234567#散点图def plotScatterImg(): #返回值 fig : matplotlib.figure.Figure object ax : Axes object or array of Axes objects. fig,ax=plot.subplots() ax.plot(10*np.random.rand(10),10*np.random.rand(10),&apos;o&apos;) ax.set_title(&apos;简单散点图&apos;) #设置图标标题 plot.show() &emsp;&emsp;效果图： 参考附表python的颜色图谱(colormap), 例如在matplotlib.pyplot.imshow(X, cmap=None)中 X: 要绘制的图像或数组； cmap: 颜色图谱（colormap), 默认绘制为RGB(A)颜色空间。 颜色图谱 描述 颜色图谱 描述 row 1 col 1 row 1 col 2 hsv hsv颜色空间， 红-黄-绿-青-蓝-洋红-红 row 2 col 1 row 2 col 2 inferno 黑-红-黄 autumn 红-橙-黄 jet 蓝-青-黄-红 bone 黑-白，x线 magma 黑-红-白 cool 青-洋红 pink 黑-粉-白 copper 黑-铜 plasma 绿-红-黄 flag 红-白-蓝-黑 prism 红-黄-绿-蓝-紫-…-绿模式 gray 黑-白 spring 洋红-黄 hot 黑-红-黄-白 summer 绿-黄 viridis 蓝-绿-黄 winter 蓝-绿 学习文献[1] 官方教程 : https://matplotlib.org/users/pyplot_tutorial.html[2] matplotlib详细介绍 https://blog.csdn.net/sunshine_in_moon/article/details/46573117[3] matplotlib基础绘图函数示例 https://www.jianshu.com/p/ad14fee5fb60[4]matplotlib极坐标方法详解 https://www.cnblogs.com/kallan/p/6738577.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>plot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows搭建git环境]]></title>
    <url>%2F2018%2F07%2F14%2Fwindows%E6%90%AD%E5%BB%BAgit%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。与常用的版本控制工具 CVS, Subversion等不同，它采用了分布式版本库的方式，不必服务器端软件支持. 1. git安装&emsp;&emsp;下载git windows一路安装下来. 2. 注册github账户&emsp;&emsp;访问github官网，注册一个github账户. 3. git bash添加本地仓&emsp;&emsp;通过 git bash 客户端添加添加一个本地文件夹作为本地仓库；可以通过 pwd 命令来查看当前bash窗口的路径。&emsp;&emsp;此处静载本地f盘创建了一个git的空文夹名为:git，用来作为本地的仓库。然后，cd到git文件夹下，用git init命令初始化这个文件夹。&emsp;&emsp;初始化之后，再调用 git config --global config 本地仓库关联到远端的 github 账户，也就是你注册 github 的时候填的用户名和邮箱。&emsp;&emsp;到这里，其实已经基本建好了本地仓库和远程github仓库的连接。但是每次使用的时候都让你输入用户名和密码，很是麻烦。怎么解决呢？添加 ssh key， 可以根据官网的 git help 创建ssh秘钥。这里首先调用 $ ssh-keygen -t rsa -C &quot;liuru@host.com&quot; 调用创建秘钥的指令。&emsp;&emsp;如上图所示，使用默然的方式生成，并没有进行设置，密码根据自己的喜好设置。然后一直enter到末尾，有了这个秘钥之后，我们还需要做两件事情：1、把这个密码和github账户关联起来；2、把它和本地客户端关联起来。 关联的到github账户: 在github账户的setting地方有一个ssh key的你添加输入，生成的秘钥内容（id_rsa.pub文件中保存），到相应的地方即可; 关联本地客户端: 根据上述创建的过程中的提示，我们找到相应的.ssh/id_rsa.pub找到文件。首先确保ssh客户端能用，调用 evel &quot;$(ssh-agent -s)&quot; 命令查看, 有 agent id 即为有用； 然后, 调用 ssh-add ~/.ssh/id_rsa 把秘钥添加到ssh客户端，这样整个过程就创建完成，就可以享受git带来的便利了。4. 从github仓库clone内容&emsp;&emsp;在本地创建了一个与github的账号同名的文件夹，比如我的github上有一个仓库叫C-Cplus-plus的仓库，然后调用 $ git clone git@github.com:ruitear/C-C-plus-plus.git (其中ruitear是账户名)5. 在仓库里面创建子文件夹&emsp;&emsp;陆github账户在网页上只能以单个文件的形式进行upload，然而并不符合我们管理文档的习惯，建立文件夹来管理文档和代码是我们必须的，为此，就需要进行添加文件夹的操作，cd到相应的版本仓库的本地文件夹，调用$ git add Sort/ . 这样就在C-Cplus-plus仓库内添加了一个Sort文件夹，当然这并不是最终形式没还需要commit操作才能生效, 也就是保存到本地仓库：$ git commit -m &quot;相关说明&quot;&emsp;&emsp;最后调用push把添加之后的仓库push到github仓库了 $git push origin master ， 到这里就完成了git本地环境的搭建并与github创建了相应的连接。【注意】，当我们往已经有的仓库中添加新的代码时记得，先pull下来更新代码赖，然后在push，如果有冲突就解决冲突，没有的话就直接push。]]></content>
      <categories>
        <category>git使用</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
</search>
